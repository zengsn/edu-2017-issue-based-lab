{
  "committer" : {
    "login" : "xiaocong0323",
    "id" : 18419209,
    "avatar_url" : "https://avatars.githubusercontent.com/u/18419209?v=3",
    "gravatar_id" : "",
    "url" : "https://api.github.com/users/xiaocong0323",
    "html_url" : "https://github.com/xiaocong0323",
    "followers_url" : "https://api.github.com/users/xiaocong0323/followers",
    "following_url" : "https://api.github.com/users/xiaocong0323/following{/other_user}",
    "gists_url" : "https://api.github.com/users/xiaocong0323/gists{/gist_id}",
    "starred_url" : "https://api.github.com/users/xiaocong0323/starred{/owner}{/repo}",
    "subscriptions_url" : "https://api.github.com/users/xiaocong0323/subscriptions",
    "organizations_url" : "https://api.github.com/users/xiaocong0323/orgs",
    "repos_url" : "https://api.github.com/users/xiaocong0323/repos",
    "events_url" : "https://api.github.com/users/xiaocong0323/events{/privacy}",
    "received_events_url" : "https://api.github.com/users/xiaocong0323/received_events",
    "type" : "User",
    "site_admin" : false
  },
  "stats" : {
    "total" : 1199,
    "additions" : 595,
    "deletions" : 604
  },
  "author" : {
    "login" : "xiaocong0323",
    "id" : 18419209,
    "avatar_url" : "https://avatars.githubusercontent.com/u/18419209?v=3",
    "gravatar_id" : "",
    "url" : "https://api.github.com/users/xiaocong0323",
    "html_url" : "https://github.com/xiaocong0323",
    "followers_url" : "https://api.github.com/users/xiaocong0323/followers",
    "following_url" : "https://api.github.com/users/xiaocong0323/following{/other_user}",
    "gists_url" : "https://api.github.com/users/xiaocong0323/gists{/gist_id}",
    "starred_url" : "https://api.github.com/users/xiaocong0323/starred{/owner}{/repo}",
    "subscriptions_url" : "https://api.github.com/users/xiaocong0323/subscriptions",
    "organizations_url" : "https://api.github.com/users/xiaocong0323/orgs",
    "repos_url" : "https://api.github.com/users/xiaocong0323/repos",
    "events_url" : "https://api.github.com/users/xiaocong0323/events{/privacy}",
    "received_events_url" : "https://api.github.com/users/xiaocong0323/received_events",
    "type" : "User",
    "site_admin" : false
  },
  "html_url" : "https://github.com/hzuapps/android-labs/commit/bc077610120f29da2e522782966bd3a400d078b7",
  "commit" : {
    "author" : {
      "name" : "unknown",
      "email" : "479552341@qq.com",
      "date" : "2016-04-27T09:19:57Z"
    },
    "committer" : {
      "name" : "unknown",
      "email" : "479552341@qq.com",
      "date" : "2016-04-27T09:19:57Z"
    },
    "message" : "#88 #122 修改代码文件件",
    "tree" : {
      "sha" : "447bfb1751d584b771f72db1a54ca8ba977d75d3",
      "url" : "https://api.github.com/repos/hzuapps/android-labs/git/trees/447bfb1751d584b771f72db1a54ca8ba977d75d3"
    },
    "url" : "https://api.github.com/repos/hzuapps/android-labs/git/commits/bc077610120f29da2e522782966bd3a400d078b7",
    "comment_count" : 0
  },
  "comments_url" : "https://api.github.com/repos/hzuapps/android-labs/commits/bc077610120f29da2e522782966bd3a400d078b7/comments",
  "files" : [ {
    "sha" : "86c23c8f074e8773c523e56f3737d21097085aaf",
    "filename" : "app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DSwitchView.java",
    "status" : "modified",
    "additions" : 330,
    "deletions" : 330,
    "changes" : 660,
    "blob_url" : "https://github.com/hzuapps/android-labs/blob/bc077610120f29da2e522782966bd3a400d078b7/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DSwitchView.java",
    "raw_url" : "https://github.com/hzuapps/android-labs/raw/bc077610120f29da2e522782966bd3a400d078b7/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DSwitchView.java",
    "contents_url" : "https://api.github.com/repos/hzuapps/android-labs/contents/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DSwitchView.java?ref=bc077610120f29da2e522782966bd3a400d078b7",
    "patch" : "@@ -10,356 +10,356 @@\n import android.widget.Scroller;\n \n /**\n- * 3D图片轮播器主控件。\n- * \n+ * Created by XIAOCONG_HOME on 2016/4/27 0027.\n  */\n public class Net1314080903203Image3DSwitchView extends ViewGroup {\n+    /**\n+     * 图片左右两边的空白间距\n+     */\n+    public static final int IMAGE_PADDING = 10;\n+    private static final int TOUCH_STATE_REST = 0;\n+    private static final int TOUCH_STATE_SCROLLING = 1;\n+    /**\n+     * 滚动到下一张图片的速度\n+     */\n+    private static final int SNAP_VELOCITY = 600;\n+    /**\n+     * 表示滚动到下一张图片这个动作\n+     */\n+    private static final int SCROLL_NEXT = 0;\n+    /**\n+     * 表示滚动到上一张图片这个动作\n+     */\n+    private static final int SCROLL_PREVIOUS = 1;\n+    /**\n+     * 表示滚动回原图片这个动作\n+     */\n+    private static final int SCROLL_BACK = 2;\n+    private static Handler handler = new Handler();\n+    /**\n+     * 控件宽度\n+     */\n+    public static int mWidth;\n+    private VelocityTracker mVelocityTracker;\n+    private Scroller mScroller;\n+    /**\n+     * 图片滚动监听器，当图片发生滚动时回调这个接口\n+     */\n+    private OnImageSwitchListener mListener;\n+    /**\n+     * 记录当前的触摸状态\n+     */\n+    private int mTouchState = TOUCH_STATE_REST;\n+    /**\n+     * 记录被判定为滚动运动的最小滚动值\n+     */\n+    private int mTouchSlop;\n+    /**\n+     * 记录控件高度\n+     */\n+    private int mHeight;\n+    /**\n+     * 记录每张图片的宽度\n+     */\n+    private int mImageWidth;\n+    /**\n+     * 记录图片的总数量\n+     */\n+    private int mCount;\n+    /**\n+     * 记录当前显示图片的坐标\n+     */\n+    private int mCurrentImage;\n+    /**\n+     * 记录上次触摸的横坐标值\n+     */\n+    private float mLastMotionX;\n+    /**\n+     * 是否强制重新布局\n+     */\n+    private boolean forceToRelayout;\n+    private int[] mItems;\n \n-\t/**\n-\t * 图片左右两边的空白间距\n-\t */\n-\tpublic static final int IMAGE_PADDING = 10;\n-\tprivate static final int TOUCH_STATE_REST = 0;\n-\tprivate static final int TOUCH_STATE_SCROLLING = 1;\n-\t/**\n-\t * 滚动到下一张图片的速度\n-\t */\n-\tprivate static final int SNAP_VELOCITY = 600;\n-\t/**\n-\t * 表示滚动到下一张图片这个动作\n-\t */\n-\tprivate static final int SCROLL_NEXT = 0;\n-\t/**\n-\t * 表示滚动到上一张图片这个动作\n-\t */\n-\tprivate static final int SCROLL_PREVIOUS = 1;\n-\t/**\n-\t * 表示滚动回原图片这个动作\n-\t */\n-\tprivate static final int SCROLL_BACK = 2;\n-\tprivate static Handler handler = new Handler();\n-\t/**\n-\t * 控件宽度\n-\t */\n-\tpublic static int mWidth;\n-\tprivate VelocityTracker mVelocityTracker;\n-\tprivate Scroller mScroller;\n-\t/**\n-\t * 图片滚动监听器，当图片发生滚动时回调这个接口\n-\t */\n-\tprivate OnImageSwitchListener mListener;\n-\t/**\n-\t * 记录当前的触摸状态\n-\t */\n-\tprivate int mTouchState = TOUCH_STATE_REST;\n-\t/**\n-\t * 记录被判定为滚动运动的最小滚动值\n-\t */\n-\tprivate int mTouchSlop;\n-\t/**\n-\t * 记录控件高度\n-\t */\n-\tprivate int mHeight;\n-\t/**\n-\t * 记录每张图片的宽度\n-\t */\n-\tprivate int mImageWidth;\n-\t/**\n-\t * 记录图片的总数量\n-\t */\n-\tprivate int mCount;\n-\t/**\n-\t * 记录当前显示图片的坐标\n-\t */\n-\tprivate int mCurrentImage;\n-\t/**\n-\t * 记录上次触摸的横坐标值\n-\t */\n-\tprivate float mLastMotionX;\n-\t/**\n-\t * 是否强制重新布局\n-\t */\n-\tprivate boolean forceToRelayout;\n-\tprivate int[] mItems;\n+    public Net1314080903203Image3DSwitchView(Context context, AttributeSet attrs) {\n+        super(context, attrs);\n+        mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();\n+        mScroller = new Scroller(context);\n+    }\n \n-\tpublic Net1314080903203Image3DSwitchView(Context context, AttributeSet attrs) {\n-\t\tsuper(context, attrs);\n-\t\tmTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();\n-\t\tmScroller = new Scroller(context);\n-\t}\n+    @Override\n+    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n+        if (changed || forceToRelayout) {\n+            mCount = getChildCount();\n+            // 图片数量必须大于5，不然无法正常显示\n+            if (mCount < 5) {\n+                return;\n+            }\n+            mWidth = getMeasuredWidth();\n+            mHeight = getMeasuredHeight();\n+            // 每张图片的宽度设定为控件宽度的百分之六十\n+            mImageWidth = (int) (mWidth * 0.6);\n+            if (mCurrentImage >= 0 && mCurrentImage < mCount) {\n+                mScroller.abortAnimation();\n+                setScrollX(0);\n+                int left = -mImageWidth * 2 + (mWidth - mImageWidth) / 2;\n+                // 分别获取每个位置上应该显示的图片下标\n+                int[] items = { getIndexForItem(1), getIndexForItem(2),\n+                        getIndexForItem(3), getIndexForItem(4),\n+                        getIndexForItem(5) };\n+                mItems = items;\n+                // 通过循环为每张图片设定位置\n+                for (int i = 0; i < items.length; i++) {\n+                    Net1314080903203Image3DView childView = (Net1314080903203Image3DView) getChildAt(items[i]);\n+                    childView.layout(left + IMAGE_PADDING, 0, left\n+                            + mImageWidth - IMAGE_PADDING, mHeight);\n+                    childView.initImageViewBitmap();\n+                    left = left + mImageWidth;\n+                }\n+                refreshImageShowing();\n+            }\n+            forceToRelayout = false;\n+        }\n+    }\n \n-\t@Override\n-\tprotected void onLayout(boolean changed, int l, int t, int r, int b) {\n-\t\tif (changed || forceToRelayout) {\n-\t\t\tmCount = getChildCount();\n-\t\t\t// 图片数量必须大于5，不然无法正常显示\n-\t\t\tif (mCount < 5) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tmWidth = getMeasuredWidth();\n-\t\t\tmHeight = getMeasuredHeight();\n-\t\t\t// 每张图片的宽度设定为控件宽度的百分之六十\n-\t\t\tmImageWidth = (int) (mWidth * 0.6);\n-\t\t\tif (mCurrentImage >= 0 && mCurrentImage < mCount) {\n-\t\t\t\tmScroller.abortAnimation();\n-\t\t\t\tsetScrollX(0);\n-\t\t\t\tint left = -mImageWidth * 2 + (mWidth - mImageWidth) / 2;\n-\t\t\t\t// 分别获取每个位置上应该显示的图片下标\n-\t\t\t\tint[] items = { getIndexForItem(1), getIndexForItem(2),\n-\t\t\t\t\t\tgetIndexForItem(3), getIndexForItem(4),\n-\t\t\t\t\t\tgetIndexForItem(5) };\n-\t\t\t\tmItems = items;\n-\t\t\t\t// 通过循环为每张图片设定位置\n-\t\t\t\tfor (int i = 0; i < items.length; i++) {\n-\t\t\t\t\tImage3DView childView = (Image3DView) getChildAt(items[i]);\n-\t\t\t\t\tchildView.layout(left + IMAGE_PADDING, 0, left\n-\t\t\t\t\t\t\t+ mImageWidth - IMAGE_PADDING, mHeight);\n-\t\t\t\t\tchildView.initImageViewBitmap();\n-\t\t\t\t\tleft = left + mImageWidth;\n-\t\t\t\t}\n-\t\t\t\trefreshImageShowing();\n-\t\t\t}\n-\t\t\tforceToRelayout = false;\n-\t\t}\n-\t}\n \n-\t@Override\n-\tpublic boolean onTouchEvent(MotionEvent event) {\n-\t\tif (mScroller.isFinished()) {\n-\t\t\tif (mVelocityTracker == null) {\n-\t\t\t\tmVelocityTracker = VelocityTracker.obtain();\n-\t\t\t}\n-\t\t\tmVelocityTracker.addMovement(event);\n-\t\t\tint action = event.getAction();\n-\t\t\tfloat x = event.getX();\n-\t\t\tswitch (action) {\n-\t\t\tcase MotionEvent.ACTION_DOWN:\n-\t\t\t\t// 记录按下时的横坐标\n-\t\t\t\tmLastMotionX = x;\n-\t\t\t\tbreak;\n-\t\t\tcase MotionEvent.ACTION_MOVE:\n-\t\t\t\tint disX = (int) (mLastMotionX - x);\n-\t\t\t\tmLastMotionX = x;\n-\t\t\t\tscrollBy(disX, 0);\n-\t\t\t\t// 当发生移动时刷新图片的显示状态\n-\t\t\t\trefreshImageShowing();\n-\t\t\t\tbreak;\n-\t\t\tcase MotionEvent.ACTION_UP:\n-\t\t\t\tmVelocityTracker.computeCurrentVelocity(1000);\n-\t\t\t\tint velocityX = (int) mVelocityTracker.getXVelocity();\n-\t\t\t\tif (shouldScrollToNext(velocityX)) {\n-\t\t\t\t\t// 滚动到下一张图\n-\t\t\t\t\tscrollToNext();\n-\t\t\t\t} else if (shouldScrollToPrevious(velocityX)) {\n-\t\t\t\t\t// 滚动到上一张图\n-\t\t\t\t\tscrollToPrevious();\n-\t\t\t\t} else {\n-\t\t\t\t\t// 滚动回当前图片\n-\t\t\t\t\tscrollBack();\n-\t\t\t\t}\n-\t\t\t\tif (mVelocityTracker != null) {\n-\t\t\t\t\tmVelocityTracker.recycle();\n-\t\t\t\t\tmVelocityTracker = null;\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn true;\n-\t}\n \n-\t/**\n-\t * 根据当前的触摸状态来决定是否屏蔽子控件的交互能力。\n-\t */\n-\t@Override\n-\tpublic boolean onInterceptTouchEvent(MotionEvent ev) {\n-\t\tint action = ev.getAction();\n-\t\tif ((action == MotionEvent.ACTION_MOVE)\n-\t\t\t\t&& (mTouchState != TOUCH_STATE_REST)) {\n-\t\t\treturn true;\n-\t\t}\n-\t\tfloat x = ev.getX();\n-\t\tswitch (action) {\n-\t\tcase MotionEvent.ACTION_DOWN:\n-\t\t\tmLastMotionX = x;\n-\t\t\tmTouchState = TOUCH_STATE_REST;\n-\t\t\tbreak;\n-\t\tcase MotionEvent.ACTION_MOVE:\n-\t\t\tint xDiff = (int) Math.abs(mLastMotionX - x);\n-\t\t\tif (xDiff > mTouchSlop) {\n-\t\t\t\tmTouchState = TOUCH_STATE_SCROLLING;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase MotionEvent.ACTION_UP:\n-\t\tdefault:\n-\t\t\tmTouchState = TOUCH_STATE_REST;\n-\t\t\tbreak;\n-\t\t}\n-\t\treturn mTouchState != TOUCH_STATE_REST;\n-\t}\n+    @Override\n+    public boolean onTouchEvent(MotionEvent event) {\n+        if (mScroller.isFinished()) {\n+            if (mVelocityTracker == null) {\n+                mVelocityTracker = VelocityTracker.obtain();\n+            }\n+            mVelocityTracker.addMovement(event);\n+            int action = event.getAction();\n+            float x = event.getX();\n+            switch (action) {\n+                case MotionEvent.ACTION_DOWN:\n+                    // 记录按下时的横坐标\n+                    mLastMotionX = x;\n+                    break;\n+                case MotionEvent.ACTION_MOVE:\n+                    int disX = (int) (mLastMotionX - x);\n+                    mLastMotionX = x;\n+                    scrollBy(disX, 0);\n+                    // 当发生移动时刷新图片的显示状态\n+                    refreshImageShowing();\n+                    break;\n+                case MotionEvent.ACTION_UP:\n+                    mVelocityTracker.computeCurrentVelocity(1000);\n+                    int velocityX = (int) mVelocityTracker.getXVelocity();\n+                    if (shouldScrollToNext(velocityX)) {\n+                        // 滚动到下一张图\n+                        scrollToNext();\n+                    } else if (shouldScrollToPrevious(velocityX)) {\n+                        // 滚动到上一张图\n+                        scrollToPrevious();\n+                    } else {\n+                        // 滚动回当前图片\n+                        scrollBack();\n+                    }\n+                    if (mVelocityTracker != null) {\n+                        mVelocityTracker.recycle();\n+                        mVelocityTracker = null;\n+                    }\n+                    break;\n+            }\n+        }\n+        return true;\n+    }\n \n-\t@Override\n-\tpublic void computeScroll() {\n-\t\tif (mScroller.computeScrollOffset()) {\n-\t\t\tscrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n-\t\t\trefreshImageShowing();\n-\t\t\tpostInvalidate();\n-\t\t}\n-\t}\n+    /**\n+     * 根据当前的触摸状态来决定是否屏蔽子控件的交互能力。\n+     */\n+    @Override\n+    public boolean onInterceptTouchEvent(MotionEvent ev) {\n+        int action = ev.getAction();\n+        if ((action == MotionEvent.ACTION_MOVE)\n+                && (mTouchState != TOUCH_STATE_REST)) {\n+            return true;\n+        }\n+        float x = ev.getX();\n+        switch (action) {\n+            case MotionEvent.ACTION_DOWN:\n+                mLastMotionX = x;\n+                mTouchState = TOUCH_STATE_REST;\n+                break;\n+            case MotionEvent.ACTION_MOVE:\n+                int xDiff = (int) Math.abs(mLastMotionX - x);\n+                if (xDiff > mTouchSlop) {\n+                    mTouchState = TOUCH_STATE_SCROLLING;\n+                }\n+                break;\n+            case MotionEvent.ACTION_UP:\n+            default:\n+                mTouchState = TOUCH_STATE_REST;\n+                break;\n+        }\n+        return mTouchState != TOUCH_STATE_REST;\n+    }\n \n-\t/**\n-\t * 设置图片滚动的监听器，每当有图片滚动时会回调此接口。\n-\t * \n-\t * @param listener\n-\t *            图片滚动监听器\n-\t */\n-\tpublic void setOnImageSwitchListener(OnImageSwitchListener listener) {\n-\t\tmListener = listener;\n-\t}\n+    @Override\n+    public void computeScroll() {\n+        if (mScroller.computeScrollOffset()) {\n+            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n+            refreshImageShowing();\n+            postInvalidate();\n+        }\n+    }\n \n-\t/**\n-\t * 设置当前显示图片的下标，注意如果该值小于零或大于等于图片的总数量，图片则无法正常显示。\n-\t * \n-\t * @param currentImage\n-\t *            图片的下标\n-\t */\n-\tpublic void setCurrentImage(int currentImage) {\n-\t\tmCurrentImage = currentImage;\n-\t\trequestLayout();\n-\t}\n+    /**\n+     * 设置图片滚动的监听器，每当有图片滚动时会回调此接口。\n+     *\n+     * @param listener\n+     *            图片滚动监听器\n+     */\n+    public void setOnImageSwitchListener(OnImageSwitchListener listener) {\n+        mListener = listener;\n+    }\n \n-\t/**\n-\t * 滚动到下一张图片。\n-\t */\n-\tpublic void scrollToNext() {\n-\t\tif (mScroller.isFinished()) {\n-\t\t\tint disX = mImageWidth - getScrollX();\n-\t\t\tcheckImageSwitchBorder(SCROLL_NEXT);\n-\t\t\tif (mListener != null) {\n-\t\t\t\tmListener.onImageSwitch(mCurrentImage);\n-\t\t\t}\n-\t\t\tbeginScroll(getScrollX(), 0, disX, 0, SCROLL_NEXT);\n-\t\t}\n-\t}\n+    /**\n+     * 设置当前显示图片的下标，注意如果该值小于零或大于等于图片的总数量，图片则无法正常显示。\n+     *\n+     * @param currentImage\n+     *            图片的下标\n+     */\n+    public void setCurrentImage(int currentImage) {\n+        mCurrentImage = currentImage;\n+        requestLayout();\n+    }\n \n-\t/**\n-\t * 滚动到上一张图片。\n-\t */\n-\tpublic void scrollToPrevious() {\n-\t\tif (mScroller.isFinished()) {\n-\t\t\tint disX = -mImageWidth - getScrollX();\n-\t\t\tcheckImageSwitchBorder(SCROLL_PREVIOUS);\n-\t\t\tif (mListener != null) {\n-\t\t\t\tmListener.onImageSwitch(mCurrentImage);\n-\t\t\t}\n-\t\t\tbeginScroll(getScrollX(), 0, disX, 0, SCROLL_PREVIOUS);\n-\t\t}\n-\t}\n+    /**\n+     * 滚动到下一张图片。\n+     */\n+    public void scrollToNext() {\n+        if (mScroller.isFinished()) {\n+            int disX = mImageWidth - getScrollX();\n+            checkImageSwitchBorder(SCROLL_NEXT);\n+            if (mListener != null) {\n+                mListener.onImageSwitch(mCurrentImage);\n+            }\n+            beginScroll(getScrollX(), 0, disX, 0, SCROLL_NEXT);\n+        }\n+    }\n \n-\t/**\n-\t * 滚动回原图片。\n-\t */\n-\tpublic void scrollBack() {\n-\t\tif (mScroller.isFinished()) {\n-\t\t\tbeginScroll(getScrollX(), 0, -getScrollX(), 0, SCROLL_BACK);\n-\t\t}\n-\t}\n+    /**\n+     * 滚动到上一张图片。\n+     */\n+    public void scrollToPrevious() {\n+        if (mScroller.isFinished()) {\n+            int disX = -mImageWidth - getScrollX();\n+            checkImageSwitchBorder(SCROLL_PREVIOUS);\n+            if (mListener != null) {\n+                mListener.onImageSwitch(mCurrentImage);\n+            }\n+            beginScroll(getScrollX(), 0, disX, 0, SCROLL_PREVIOUS);\n+        }\n+    }\n \n-\t/**\n-\t * 回收所有图片对象，释放内存。\n-\t */\n-\tpublic void clear() {\n-\t\tfor (int i = 0; i < mCount; i++) {\n-\t\t\tImage3DView childView = (Image3DView) getChildAt(i);\n-\t\t\tchildView.recycleBitmap();\n-\t\t}\n-\t}\n+    /**\n+     * 滚动回原图片。\n+     */\n+    public void scrollBack() {\n+        if (mScroller.isFinished()) {\n+            beginScroll(getScrollX(), 0, -getScrollX(), 0, SCROLL_BACK);\n+        }\n+    }\n \n-\t/**\n-\t * 让控件中的所有图片开始滚动。\n-\t */\n-\tprivate void beginScroll(int startX, int startY, int dx, int dy,\n-\t\t\tfinal int action) {\n-\t\tint duration = (int) (700f / mImageWidth * Math.abs(dx));\n-\t\tmScroller.startScroll(startX, startY, dx, dy, duration);\n-\t\tinvalidate();\n-\t\thandler.postDelayed(new Runnable() {\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tif (action == SCROLL_NEXT || action == SCROLL_PREVIOUS) {\n-\t\t\t\t\tforceToRelayout = true;\n-\t\t\t\t\trequestLayout();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}, duration);\n-\t}\n+    /**\n+     * 回收所有图片对象，释放内存。\n+     */\n+    public void clear() {\n+        for (int i = 0; i < mCount; i++) {\n+            Net1314080903203Image3DView childView = (Net1314080903203Image3DView) getChildAt(i);\n+            childView.recycleBitmap();\n+        }\n+    }\n \n-\t/**\n-\t * 根据当前图片的下标和传入的item参数，来判断item位置上应该显示哪张图片。\n-\t * \n-\t * @param item\n-\t *            取值范围是1-5\n-\t * @return 对应item位置上应该显示哪张图片。\n-\t */\n-\tprivate int getIndexForItem(int item) {\n-\t\tint index = -1;\n-\t\tindex = mCurrentImage + item - 3;\n-\t\twhile (index < 0) {\n-\t\t\tindex = index + mCount;\n-\t\t}\n-\t\twhile (index > mCount - 1) {\n-\t\t\tindex = index - mCount;\n-\t\t}\n-\t\treturn index;\n-\t}\n+    /**\n+     * 让控件中的所有图片开始滚动。\n+     */\n+    private void beginScroll(int startX, int startY, int dx, int dy,\n+                             final int action) {\n+        int duration = (int) (700f / mImageWidth * Math.abs(dx));\n+        mScroller.startScroll(startX, startY, dx, dy, duration);\n+        invalidate();\n+        handler.postDelayed(new Runnable() {\n+            @Override\n+            public void run() {\n+                if (action == SCROLL_NEXT || action == SCROLL_PREVIOUS) {\n+                    forceToRelayout = true;\n+                    requestLayout();\n+                }\n+            }\n+        }, duration);\n+    }\n \n-\t/**\n-\t * 刷新所有图片的显示状态，包括当前的旋转角度。\n-\t */\n-\tprivate void refreshImageShowing() {\n-\t\tfor (int i = 0; i < mItems.length; i++) {\n-\t\t\tImage3DView childView = (Image3DView) getChildAt(mItems[i]);\n-\t\t\tchildView.setRotateData(i, getScrollX());\n-\t\t\tchildView.invalidate();\n-\t\t}\n-\t}\n+    /**\n+     * 根据当前图片的下标和传入的item参数，来判断item位置上应该显示哪张图片。\n+     *\n+     * @param item\n+     *            取值范围是1-5\n+     * @return 对应item位置上应该显示哪张图片。\n+     */\n+    private int getIndexForItem(int item) {\n+        int index = -1;\n+        index = mCurrentImage + item - 3;\n+        while (index < 0) {\n+            index = index + mCount;\n+        }\n+        while (index > mCount - 1) {\n+            index = index - mCount;\n+        }\n+        return index;\n+    }\n \n-\t/**\n-\t * 检查图片的边界，防止图片的下标超出规定范围。\n-\t */\n-\tprivate void checkImageSwitchBorder(int action) {\n-\t\tif (action == SCROLL_NEXT && ++mCurrentImage >= mCount) {\n-\t\t\tmCurrentImage = 0;\n-\t\t} else if (action == SCROLL_PREVIOUS && --mCurrentImage < 0) {\n-\t\t\tmCurrentImage = mCount - 1;\n-\t\t}\n-\t}\n+    /**\n+     * 刷新所有图片的显示状态，包括当前的旋转角度。\n+     */\n+    private void refreshImageShowing() {\n+        for (int i = 0; i < mItems.length; i++) {\n+            Net1314080903203Image3DView childView = (Net1314080903203Image3DView) getChildAt(mItems[i]);\n+            childView.setRotateData(i, getScrollX());\n+            childView.invalidate();\n+        }\n+    }\n \n-\t/**\n-\t * 判断是否应该滚动到下一张图片。\n-\t */\n-\tprivate boolean shouldScrollToNext(int velocityX) {\n-\t\treturn velocityX < -SNAP_VELOCITY || getScrollX() > mImageWidth / 2;\n-\t}\n+    /**\n+     * 检查图片的边界，防止图片的下标超出规定范围。\n+     */\n+    private void checkImageSwitchBorder(int action) {\n+        if (action == SCROLL_NEXT && ++mCurrentImage >= mCount) {\n+            mCurrentImage = 0;\n+        } else if (action == SCROLL_PREVIOUS && --mCurrentImage < 0) {\n+            mCurrentImage = mCount - 1;\n+        }\n+    }\n \n-\t/**\n-\t * 判断是否应该滚动到上一张图片。\n-\t */\n-\tprivate boolean shouldScrollToPrevious(int velocityX) {\n-\t\treturn velocityX > SNAP_VELOCITY || getScrollX() < -mImageWidth / 2;\n-\t}\n+    /**\n+     * 判断是否应该滚动到下一张图片。\n+     */\n+    private boolean shouldScrollToNext(int velocityX) {\n+        return velocityX < -SNAP_VELOCITY || getScrollX() > mImageWidth / 2;\n+    }\n \n-\t/**\n-\t * 图片滚动的监听器\n-\t */\n-\tpublic interface OnImageSwitchListener {\n+    /**\n+     * 判断是否应该滚动到上一张图片。\n+     */\n+    private boolean shouldScrollToPrevious(int velocityX) {\n+        return velocityX > SNAP_VELOCITY || getScrollX() < -mImageWidth / 2;\n+    }\n \n-\t\t/**\n-\t\t * 当图片滚动时会回调此方法\n-\t\t * \n-\t\t * @param currentImage\n-\t\t *            当前图片的坐标\n-\t\t */\n-\t\tvoid onImageSwitch(int currentImage);\n+    /**\n+     * 图片滚动的监听器\n+     */\n+    public interface OnImageSwitchListener {\n \n-\t}\n-}\n+        /**\n+         * 当图片滚动时会回调此方法\n+         *\n+         * @param currentImage\n+         *            当前图片的坐标\n+         */\n+        void onImageSwitch(int currentImage);\n+\n+    }\n+}\n\\ No newline at end of file"
  }, {
    "sha" : "8e8b505bce64ca89703ccf4533a191cb7d0e42ae",
    "filename" : "app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DView.java",
    "status" : "modified",
    "additions" : 244,
    "deletions" : 246,
    "changes" : 490,
    "blob_url" : "https://github.com/hzuapps/android-labs/blob/bc077610120f29da2e522782966bd3a400d078b7/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DView.java",
    "raw_url" : "https://github.com/hzuapps/android-labs/raw/bc077610120f29da2e522782966bd3a400d078b7/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DView.java",
    "contents_url" : "https://api.github.com/repos/hzuapps/android-labs/contents/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DView.java?ref=bc077610120f29da2e522782966bd3a400d078b7",
    "patch" : "@@ -12,264 +12,262 @@\n import android.widget.ImageView;\n \n /**\n- * 用于在Image3DSwitchView中显示3D图片。\n- * \n-\n+ * Created by XIAOCONG_HOME on 2016/4/27 0027.\n  */\n public class Net1314080903203Image3DView extends ImageView {\n-\t/**\n-\t * 旋转角度的基准值\n-\t */\n-\tprivate static final float BASE_DEGREE = 50f;\n-\t/**\n-\t * 旋转深度的基准值\n-\t */\n-\tprivate static final float BASE_DEEP = 150f;\n-\tprivate Camera mCamera;\n-\tprivate Matrix mMaxtrix;\n-\tprivate Bitmap mBitmap;\n-\t/**\n-\t * 当前图片对应的下标\n-\t */\n-\tprivate int mIndex;\n-\t/**\n-\t * 在前图片在X轴方向滚动的距离\n-\t */\n-\tprivate int mScrollX;\n-\t/**\n-\t * Image3DSwitchView控件的宽度\n-\t */\n-\tprivate int mLayoutWidth;\n-\t/**\n-\t * 当前图片的宽度\n-\t */\n-\tprivate int mWidth;\n-\t/**\n-\t * 当前旋转的角度\n-\t */\n-\tprivate float mRotateDegree;\n-\t/**\n-\t * 旋转的中心点\n-\t */\n-\tprivate float mDx;\n-\t/**\n-\t * 旋转的深度\n-\t */\n-\tprivate float mDeep;\n+    /**\n+     * 旋转角度的基准值\n+     */\n+    private static final float BASE_DEGREE = 50f;\n+    /**\n+     * 旋转深度的基准值\n+     */\n+    private static final float BASE_DEEP = 150f;\n+    private Camera mCamera;\n+    private Matrix mMaxtrix;\n+    private Bitmap mBitmap;\n+    /**\n+     * 当前图片对应的下标\n+     */\n+    private int mIndex;\n+    /**\n+     * 在前图片在X轴方向滚动的距离\n+     */\n+    private int mScrollX;\n+    /**\n+     * Image3DSwitchView控件的宽度\n+     */\n+    private int mLayoutWidth;\n+    /**\n+     * 当前图片的宽度\n+     */\n+    private int mWidth;\n+    /**\n+     * 当前旋转的角度\n+     */\n+    private float mRotateDegree;\n+    /**\n+     * 旋转的中心点\n+     */\n+    private float mDx;\n+    /**\n+     * 旋转的深度\n+     */\n+    private float mDeep;\n \n-\tpublic Net1314080903203Image3DView(Context context, AttributeSet attrs) {\n-\t\tsuper(context, attrs);\n-\t\tmCamera = new Camera();\n-\t\tmMaxtrix = new Matrix();\n-\t}\n+    public Net1314080903203Image3DView(Context context, AttributeSet attrs) {\n+        super(context, attrs);\n+        mCamera = new Camera();\n+        mMaxtrix = new Matrix();\n+    }\n \n-\t/**\n-\t * 初始化Image3DView所需要的信息，包括图片宽度，截取背景图等。\n-\t */\n-\tpublic void initImageViewBitmap() {\n-\t\tif (mBitmap == null) {\n-\t\t\tsetDrawingCacheEnabled(true);\n-\t\t\tbuildDrawingCache();\n-\t\t\tmBitmap = getDrawingCache();\n-\t\t}\n-\t\tmLayoutWidth = Image3DSwitchView.mWidth;\n-\t\tmWidth = getWidth() + Image3DSwitchView.IMAGE_PADDING * 2;\n-\t}\n+    /**\n+     * 初始化Image3DView所需要的信息，包括图片宽度，截取背景图等。\n+     */\n+    public void initImageViewBitmap() {\n+        if (mBitmap == null) {\n+            setDrawingCacheEnabled(true);\n+            buildDrawingCache();\n+            mBitmap = getDrawingCache();\n+        }\n+        mLayoutWidth = Net1314080903203Image3DSwitchView.mWidth;\n+        mWidth = getWidth() + Net1314080903203Image3DSwitchView.IMAGE_PADDING * 2;\n+    }\n \n-\t/**\n-\t * 设置旋转角度。\n-\t * \n-\t * @param index\n-\t *            当前图片的下标\n-\t * @param scrollX\n-\t *            当前图片在X轴方向滚动的距离\n-\t */\n-\tpublic void setRotateData(int index, int scrollX) {\n-\t\tmIndex = index;\n-\t\tmScrollX = scrollX;\n-\t}\n+    /**\n+     * 设置旋转角度。\n+     *\n+     * @param index\n+     *            当前图片的下标\n+     * @param scrollX\n+     *            当前图片在X轴方向滚动的距离\n+     */\n+    public void setRotateData(int index, int scrollX) {\n+        mIndex = index;\n+        mScrollX = scrollX;\n+    }\n \n-\t/**\n-\t * 回收当前的Bitmap对象，以释放内存。\n-\t */\n-\tpublic void recycleBitmap() {\n-\t\tif (mBitmap != null && !mBitmap.isRecycled()) {\n-\t\t\tmBitmap.recycle();\n-\t\t}\n-\t}\n+    /**\n+     * 回收当前的Bitmap对象，以释放内存。\n+     */\n+    public void recycleBitmap() {\n+        if (mBitmap != null && !mBitmap.isRecycled()) {\n+            mBitmap.recycle();\n+        }\n+    }\n \n-\t@Override\n-\tpublic void setImageResource(int resId) {\n-\t\tsuper.setImageResource(resId);\n-\t\tmBitmap = null;\n-\t\tinitImageViewBitmap();\n-\t}\n+    @Override\n+    public void setImageResource(int resId) {\n+        super.setImageResource(resId);\n+        mBitmap = null;\n+        initImageViewBitmap();\n+    }\n \n-\t@Override\n-\tpublic void setImageBitmap(Bitmap bm) {\n-\t\tsuper.setImageBitmap(bm);\n-\t\tmBitmap = null;\n-\t\tinitImageViewBitmap();\n-\t}\n+    @Override\n+    public void setImageBitmap(Bitmap bm) {\n+        super.setImageBitmap(bm);\n+        mBitmap = null;\n+        initImageViewBitmap();\n+    }\n \n-\t@Override\n-\tpublic void setImageDrawable(Drawable drawable) {\n-\t\tsuper.setImageDrawable(drawable);\n-\t\tmBitmap = null;\n-\t\tinitImageViewBitmap();\n-\t}\n+    @Override\n+    public void setImageDrawable(Drawable drawable) {\n+        super.setImageDrawable(drawable);\n+        mBitmap = null;\n+        initImageViewBitmap();\n+    }\n \n-\t@Override\n-\tpublic void setImageURI(Uri uri) {\n-\t\tsuper.setImageURI(uri);\n-\t\tmBitmap = null;\n-\t\tinitImageViewBitmap();\n-\t}\n+    @Override\n+    public void setImageURI(Uri uri) {\n+        super.setImageURI(uri);\n+        mBitmap = null;\n+        initImageViewBitmap();\n+    }\n \n-\t@Override\n-\tprotected void onDraw(Canvas canvas) {\n-\t\tif (mBitmap == null) {\n-\t\t\t// 如果Bitmap对象还不存在，先使用父类的onDraw方法进行绘制\n-\t\t\tsuper.onDraw(canvas);\n-\t\t} else {\n-\t\t\tif (isImageVisible()) {\n-\t\t\t\t// 绘图时需要注意，只有当图片可见的时候才进行绘制，这样可以节省运算效率\n-\t\t\t\tcomputeRotateData();\n-\t\t\t\tmCamera.save();\n-\t\t\t\tmCamera.translate(0.0f, 0.0f, mDeep);\n-\t\t\t\tmCamera.rotateY(mRotateDegree);\n-\t\t\t\tmCamera.getMatrix(mMaxtrix);\n-\t\t\t\tmCamera.restore();\n-\t\t\t\tmMaxtrix.preTranslate(-mDx, -getHeight() / 2);\n-\t\t\t\tmMaxtrix.postTranslate(mDx, getHeight() / 2);\n-\t\t\t\tcanvas.drawBitmap(mBitmap, mMaxtrix, null);\n-\t\t\t}\n-\t\t}\n-\t}\n+    @Override\n+    protected void onDraw(Canvas canvas) {\n+        if (mBitmap == null) {\n+            // 如果Bitmap对象还不存在，先使用父类的onDraw方法进行绘制\n+            super.onDraw(canvas);\n+        } else {\n+            if (isImageVisible()) {\n+                // 绘图时需要注意，只有当图片可见的时候才进行绘制，这样可以节省运算效率\n+                computeRotateData();\n+                mCamera.save();\n+                mCamera.translate(0.0f, 0.0f, mDeep);\n+                mCamera.rotateY(mRotateDegree);\n+                mCamera.getMatrix(mMaxtrix);\n+                mCamera.restore();\n+                mMaxtrix.preTranslate(-mDx, -getHeight() / 2);\n+                mMaxtrix.postTranslate(mDx, getHeight() / 2);\n+                canvas.drawBitmap(mBitmap, mMaxtrix, null);\n+            }\n+        }\n+    }\n \n-\t/**\n-\t * 在这里计算所有旋转所需要的数据。\n-\t */\n-\tprivate void computeRotateData() {\n-\t\tfloat degreePerPix = BASE_DEGREE / mWidth;\n-\t\tfloat deepPerPix = BASE_DEEP / ((mLayoutWidth - mWidth) / 2);\n-\t\tswitch (mIndex) {\n-\t\tcase 0:\n-\t\t\tmDx = mWidth;\n-\t\t\tmRotateDegree = 360f - (2 * mWidth + mScrollX) * degreePerPix;\n-\t\t\tif (mScrollX < -mWidth) {\n-\t\t\t\tmDeep = 0;\n-\t\t\t} else {\n-\t\t\t\tmDeep = (mWidth + mScrollX) * deepPerPix;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase 1:\n-\t\t\tif (mScrollX > 0) {\n-\t\t\t\tmDx = mWidth;\n-\t\t\t\tmRotateDegree = (360f - BASE_DEGREE) - mScrollX * degreePerPix;\n-\t\t\t\tmDeep = mScrollX * deepPerPix;\n-\t\t\t} else {\n-\t\t\t\tif (mScrollX < -mWidth) {\n-\t\t\t\t\tmDx = -Image3DSwitchView.IMAGE_PADDING * 2;\n-\t\t\t\t\tmRotateDegree = (-mScrollX - mWidth) * degreePerPix;\n-\t\t\t\t} else {\n-\t\t\t\t\tmDx = mWidth;\n-\t\t\t\t\tmRotateDegree = 360f - (mWidth + mScrollX) * degreePerPix;\n-\t\t\t\t}\n-\t\t\t\tmDeep = 0;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase 2:\n-\t\t\tif (mScrollX > 0) {\n-\t\t\t\tmDx = mWidth;\n-\t\t\t\tmRotateDegree = 360f - mScrollX * degreePerPix;\n-\t\t\t\tmDeep = 0;\n-\t\t\t\tif (mScrollX > mWidth) {\n-\t\t\t\t\tmDeep = (mScrollX - mWidth) * deepPerPix;\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tmDx = -Image3DSwitchView.IMAGE_PADDING * 2;\n-\t\t\t\tmRotateDegree = -mScrollX * degreePerPix;\n-\t\t\t\tmDeep = 0;\n-\t\t\t\tif (mScrollX < -mWidth) {\n-\t\t\t\t\tmDeep = -(mWidth + mScrollX) * deepPerPix;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase 3:\n-\t\t\tif (mScrollX < 0) {\n-\t\t\t\tmDx = -Image3DSwitchView.IMAGE_PADDING * 2;\n-\t\t\t\tmRotateDegree = BASE_DEGREE - mScrollX * degreePerPix;\n-\t\t\t\tmDeep = -mScrollX * deepPerPix;\n-\t\t\t} else {\n-\t\t\t\tif (mScrollX > mWidth) {\n-\t\t\t\t\tmDx = mWidth;\n-\t\t\t\t\tmRotateDegree = 360f - (mScrollX - mWidth) * degreePerPix;\n-\t\t\t\t} else {\n-\t\t\t\t\tmDx = -Image3DSwitchView.IMAGE_PADDING * 2;\n-\t\t\t\t\tmRotateDegree = BASE_DEGREE - mScrollX * degreePerPix;\n-\t\t\t\t}\n-\t\t\t\tmDeep = 0;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase 4:\n-\t\t\tmDx = -Image3DSwitchView.IMAGE_PADDING * 2;\n-\t\t\tmRotateDegree = (2 * mWidth - mScrollX) * degreePerPix;\n-\t\t\tif (mScrollX > mWidth) {\n-\t\t\t\tmDeep = 0;\n-\t\t\t} else {\n-\t\t\t\tmDeep = (mWidth - mScrollX) * deepPerPix;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t}\n+    /**\n+     * 在这里计算所有旋转所需要的数据。\n+     */\n+    private void computeRotateData() {\n+        float degreePerPix = BASE_DEGREE / mWidth;\n+        float deepPerPix = BASE_DEEP / ((mLayoutWidth - mWidth) / 2);\n+        switch (mIndex) {\n+            case 0:\n+                mDx = mWidth;\n+                mRotateDegree = 360f - (2 * mWidth + mScrollX) * degreePerPix;\n+                if (mScrollX < -mWidth) {\n+                    mDeep = 0;\n+                } else {\n+                    mDeep = (mWidth + mScrollX) * deepPerPix;\n+                }\n+                break;\n+            case 1:\n+                if (mScrollX > 0) {\n+                    mDx = mWidth;\n+                    mRotateDegree = (360f - BASE_DEGREE) - mScrollX * degreePerPix;\n+                    mDeep = mScrollX * deepPerPix;\n+                } else {\n+                    if (mScrollX < -mWidth) {\n+                        mDx = -Net1314080903203Image3DSwitchView.IMAGE_PADDING * 2;\n+                        mRotateDegree = (-mScrollX - mWidth) * degreePerPix;\n+                    } else {\n+                        mDx = mWidth;\n+                        mRotateDegree = 360f - (mWidth + mScrollX) * degreePerPix;\n+                    }\n+                    mDeep = 0;\n+                }\n+                break;\n+            case 2:\n+                if (mScrollX > 0) {\n+                    mDx = mWidth;\n+                    mRotateDegree = 360f - mScrollX * degreePerPix;\n+                    mDeep = 0;\n+                    if (mScrollX > mWidth) {\n+                        mDeep = (mScrollX - mWidth) * deepPerPix;\n+                    }\n+                } else {\n+                    mDx = -Net1314080903203Image3DSwitchView.IMAGE_PADDING * 2;\n+                    mRotateDegree = -mScrollX * degreePerPix;\n+                    mDeep = 0;\n+                    if (mScrollX < -mWidth) {\n+                        mDeep = -(mWidth + mScrollX) * deepPerPix;\n+                    }\n+                }\n+                break;\n+            case 3:\n+                if (mScrollX < 0) {\n+                    mDx = -Net1314080903203Image3DSwitchView.IMAGE_PADDING * 2;\n+                    mRotateDegree = BASE_DEGREE - mScrollX * degreePerPix;\n+                    mDeep = -mScrollX * deepPerPix;\n+                } else {\n+                    if (mScrollX > mWidth) {\n+                        mDx = mWidth;\n+                        mRotateDegree = 360f - (mScrollX - mWidth) * degreePerPix;\n+                    } else {\n+                        mDx = -Net1314080903203Image3DSwitchView.IMAGE_PADDING * 2;\n+                        mRotateDegree = BASE_DEGREE - mScrollX * degreePerPix;\n+                    }\n+                    mDeep = 0;\n+                }\n+                break;\n+            case 4:\n+                mDx = -Net1314080903203Image3DSwitchView.IMAGE_PADDING * 2;\n+                mRotateDegree = (2 * mWidth - mScrollX) * degreePerPix;\n+                if (mScrollX > mWidth) {\n+                    mDeep = 0;\n+                } else {\n+                    mDeep = (mWidth - mScrollX) * deepPerPix;\n+                }\n+                break;\n+        }\n+    }\n \n-\t/**\n-\t * 判断当前图片是否可见。\n-\t * \n-\t * @return 当前图片可见返回true，不可见返回false。\n-\t */\n-\tprivate boolean isImageVisible() {\n-\t\tboolean isVisible = false;\n-\t\tswitch (mIndex) {\n-\t\tcase 0:\n-\t\t\tif (mScrollX < (mLayoutWidth - mWidth) / 2 - mWidth) {\n-\t\t\t\tisVisible = true;\n-\t\t\t} else {\n-\t\t\t\tisVisible = false;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase 1:\n-\t\t\tif (mScrollX > (mLayoutWidth - mWidth) / 2) {\n-\t\t\t\tisVisible = false;\n-\t\t\t} else {\n-\t\t\t\tisVisible = true;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase 2:\n-\t\t\tif (mScrollX > mLayoutWidth / 2 + mWidth / 2\n-\t\t\t\t\t|| mScrollX < -mLayoutWidth / 2 - mWidth / 2) {\n-\t\t\t\tisVisible = false;\n-\t\t\t} else {\n-\t\t\t\tisVisible = true;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase 3:\n-\t\t\tif (mScrollX < -(mLayoutWidth - mWidth) / 2) {\n-\t\t\t\tisVisible = false;\n-\t\t\t} else {\n-\t\t\t\tisVisible = true;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase 4:\n-\t\t\tif (mScrollX > mWidth - (mLayoutWidth - mWidth) / 2) {\n-\t\t\t\tisVisible = true;\n-\t\t\t} else {\n-\t\t\t\tisVisible = false;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t\treturn isVisible;\n-\t}\n+    /**\n+     * 判断当前图片是否可见。\n+     *\n+     * @return 当前图片可见返回true，不可见返回false。\n+     */\n+    private boolean isImageVisible() {\n+        boolean isVisible = false;\n+        switch (mIndex) {\n+            case 0:\n+                if (mScrollX < (mLayoutWidth - mWidth) / 2 - mWidth) {\n+                    isVisible = true;\n+                } else {\n+                    isVisible = false;\n+                }\n+                break;\n+            case 1:\n+                if (mScrollX > (mLayoutWidth - mWidth) / 2) {\n+                    isVisible = false;\n+                } else {\n+                    isVisible = true;\n+                }\n+                break;\n+            case 2:\n+                if (mScrollX > mLayoutWidth / 2 + mWidth / 2\n+                        || mScrollX < -mLayoutWidth / 2 - mWidth / 2) {\n+                    isVisible = false;\n+                } else {\n+                    isVisible = true;\n+                }\n+                break;\n+            case 3:\n+                if (mScrollX < -(mLayoutWidth - mWidth) / 2) {\n+                    isVisible = false;\n+                } else {\n+                    isVisible = true;\n+                }\n+                break;\n+            case 4:\n+                if (mScrollX > mWidth - (mLayoutWidth - mWidth) / 2) {\n+                    isVisible = true;\n+                } else {\n+                    isVisible = false;\n+                }\n+                break;\n+        }\n+        return isVisible;\n+    }\n \n }"
  }, {
    "sha" : "c246f4271882952e54d81181a3349df249803c6c",
    "filename" : "app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203MainActivity.java",
    "status" : "modified",
    "additions" : 21,
    "deletions" : 28,
    "changes" : 49,
    "blob_url" : "https://github.com/hzuapps/android-labs/blob/bc077610120f29da2e522782966bd3a400d078b7/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203MainActivity.java",
    "raw_url" : "https://github.com/hzuapps/android-labs/raw/bc077610120f29da2e522782966bd3a400d078b7/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203MainActivity.java",
    "contents_url" : "https://api.github.com/repos/hzuapps/android-labs/contents/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203MainActivity.java?ref=bc077610120f29da2e522782966bd3a400d078b7",
    "patch" : "@@ -3,35 +3,28 @@\n import android.app.Activity;\n import android.os.Bundle;\n \n-import com.example.imageswitchviewtest.Image3DSwitchView.OnImageSwitchListener;\n-\n+import edu.hzuapps.androidworks.homeworks.net1314080903203.Net1314080903203Image3DSwitchView.OnImageSwitchListener;\n /**\n- * 项目主Activity。\n- * \n-\n+ * Created by XIAOCONG_HOME on 2016/4/27 0027.\n  */\n public class Net1314080903203MainActivity extends Activity {\n \n-\tprivate Image3DSwitchView imageSwitchView;\n-\n-\t@Override\n-\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\tsuper.onCreate(savedInstanceState);\n-\t\tsetContentView(R.layout.activity_main);\n-\t\timageSwitchView = (Image3DSwitchView) findViewById(R.id.image_switch_view);\n-\t\timageSwitchView.setOnImageSwitchListener(new OnImageSwitchListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onImageSwitch(int currentImage) {\n-\t\t\t\t// Log.d(\"TAG\", \"current image is \" + currentImage);\n-\t\t\t}\n-\t\t});\n-\t\timageSwitchView.setCurrentImage(1);\n-\t}\n-\n-\t@Override\n-\tprotected void onDestroy() {\n-\t\tsuper.onDestroy();\n-\t\timageSwitchView.clear();\n-\t}\n-\n-}\n+    private Net1314080903203Image3DSwitchView imageSwitchView;\n+\n+    @Override\n+    protected void onCreate(Bundle savedInstanceState) {\n+        super.onCreate(savedInstanceState);\n+        setContentView(R.layout.activity_main);\n+        imageSwitchView = (Net1314080903203Image3DSwitchView) findViewById(R.id.image_switch_view);\n+        imageSwitchView.setOnImageSwitchListener(new OnImageSwitchListener() {\n+            @Override\n+            public void onImageSwitch(int currentImage) {\n+                // Log.d(\"TAG\", \"current image is \" + currentImage);\n+            }\n+        });\n+        imageSwitchView.setCurrentImage(1);\n+    }\n+\n+    @Override\n+    protected void onDestroy() {\n+        super.onDestroy();}}\n\\ No newline at end of file"
  } ],
  "sha" : "bc077610120f29da2e522782966bd3a400d078b7",
  "url" : "https://api.github.com/repos/hzuapps/android-labs/commits/bc077610120f29da2e522782966bd3a400d078b7",
  "parents" : [ {
    "sha" : "ee6705ddf067d1aa686fe20599dd4d0483549a18",
    "url" : "https://api.github.com/repos/hzuapps/android-labs/commits/ee6705ddf067d1aa686fe20599dd4d0483549a18",
    "html_url" : "https://github.com/hzuapps/android-labs/commit/ee6705ddf067d1aa686fe20599dd4d0483549a18"
  } ]
}