{
  "committer" : {
    "login" : "xiaocong0323",
    "id" : 18419209,
    "avatar_url" : "https://avatars.githubusercontent.com/u/18419209?v=3",
    "gravatar_id" : "",
    "url" : "https://api.github.com/users/xiaocong0323",
    "html_url" : "https://github.com/xiaocong0323",
    "followers_url" : "https://api.github.com/users/xiaocong0323/followers",
    "following_url" : "https://api.github.com/users/xiaocong0323/following{/other_user}",
    "gists_url" : "https://api.github.com/users/xiaocong0323/gists{/gist_id}",
    "starred_url" : "https://api.github.com/users/xiaocong0323/starred{/owner}{/repo}",
    "subscriptions_url" : "https://api.github.com/users/xiaocong0323/subscriptions",
    "organizations_url" : "https://api.github.com/users/xiaocong0323/orgs",
    "repos_url" : "https://api.github.com/users/xiaocong0323/repos",
    "events_url" : "https://api.github.com/users/xiaocong0323/events{/privacy}",
    "received_events_url" : "https://api.github.com/users/xiaocong0323/received_events",
    "type" : "User",
    "site_admin" : false
  },
  "stats" : {
    "total" : 662,
    "additions" : 331,
    "deletions" : 331
  },
  "author" : {
    "login" : "xiaocong0323",
    "id" : 18419209,
    "avatar_url" : "https://avatars.githubusercontent.com/u/18419209?v=3",
    "gravatar_id" : "",
    "url" : "https://api.github.com/users/xiaocong0323",
    "html_url" : "https://github.com/xiaocong0323",
    "followers_url" : "https://api.github.com/users/xiaocong0323/followers",
    "following_url" : "https://api.github.com/users/xiaocong0323/following{/other_user}",
    "gists_url" : "https://api.github.com/users/xiaocong0323/gists{/gist_id}",
    "starred_url" : "https://api.github.com/users/xiaocong0323/starred{/owner}{/repo}",
    "subscriptions_url" : "https://api.github.com/users/xiaocong0323/subscriptions",
    "organizations_url" : "https://api.github.com/users/xiaocong0323/orgs",
    "repos_url" : "https://api.github.com/users/xiaocong0323/repos",
    "events_url" : "https://api.github.com/users/xiaocong0323/events{/privacy}",
    "received_events_url" : "https://api.github.com/users/xiaocong0323/received_events",
    "type" : "User",
    "site_admin" : false
  },
  "html_url" : "https://github.com/hzuapps/android-labs/commit/d05600f6fdd73036ed0b751fd7727328c84d9a03",
  "commit" : {
    "author" : {
      "name" : "xiaocong0323",
      "email" : "479552341@qq.com",
      "date" : "2016-05-19T02:24:37Z"
    },
    "committer" : {
      "name" : "xiaocong0323",
      "email" : "479552341@qq.com",
      "date" : "2016-05-19T02:24:37Z"
    },
    "message" : "Update Net1314080903203Image3DSwitchView.java",
    "tree" : {
      "sha" : "0de25f98705fa7f2ab5aa68201eec7852451fee8",
      "url" : "https://api.github.com/repos/hzuapps/android-labs/git/trees/0de25f98705fa7f2ab5aa68201eec7852451fee8"
    },
    "url" : "https://api.github.com/repos/hzuapps/android-labs/git/commits/d05600f6fdd73036ed0b751fd7727328c84d9a03",
    "comment_count" : 0
  },
  "comments_url" : "https://api.github.com/repos/hzuapps/android-labs/commits/d05600f6fdd73036ed0b751fd7727328c84d9a03/comments",
  "files" : [ {
    "sha" : "fe71e514c4b4acf860527b12a728b545b5f1ea48",
    "filename" : "app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DSwitchView.java",
    "status" : "modified",
    "additions" : 331,
    "deletions" : 331,
    "changes" : 662,
    "blob_url" : "https://github.com/hzuapps/android-labs/blob/d05600f6fdd73036ed0b751fd7727328c84d9a03/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DSwitchView.java",
    "raw_url" : "https://github.com/hzuapps/android-labs/raw/d05600f6fdd73036ed0b751fd7727328c84d9a03/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DSwitchView.java",
    "contents_url" : "https://api.github.com/repos/hzuapps/android-labs/contents/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DSwitchView.java?ref=d05600f6fdd73036ed0b751fd7727328c84d9a03",
    "patch" : "@@ -1,4 +1,4 @@\n-﻿package com.example.imageswitchviewtest;\n+package edu.hzuapps.androidworks.homeworks.net1314080903203;\n \n import android.content.Context;\n import android.os.Handler;\n@@ -10,356 +10,356 @@\n import android.widget.Scroller;\n \n /**\n- * 3D图片轮播器主控件。\n- * \n+ * Created by XIAOCONG_HOME on 2016/4/27 0027.\n  */\n public class Net1314080903203Image3DSwitchView extends ViewGroup {\n+    /**\n+     * 图片左右两边的空白间距\n+     */\n+    public static final int IMAGE_PADDING = 10;\n+    private static final int TOUCH_STATE_REST = 0;\n+    private static final int TOUCH_STATE_SCROLLING = 1;\n+    /**\n+     * 滚动到下一张图片的速度\n+     */\n+    private static final int SNAP_VELOCITY = 600;\n+    /**\n+     * 表示滚动到下一张图片这个动作\n+     */\n+    private static final int SCROLL_NEXT = 0;\n+    /**\n+     * 表示滚动到上一张图片这个动作\n+     */\n+    private static final int SCROLL_PREVIOUS = 1;\n+    /**\n+     * 表示滚动回原图片这个动作\n+     */\n+    private static final int SCROLL_BACK = 2;\n+    private static Handler handler = new Handler();\n+    /**\n+     * 控件宽度\n+     */\n+    public static int mWidth;\n+    private VelocityTracker mVelocityTracker;\n+    private Scroller mScroller;\n+    /**\n+     * 图片滚动监听器，当图片发生滚动时回调这个接口\n+     */\n+    private OnImageSwitchListener mListener;\n+    /**\n+     * 记录当前的触摸状态\n+     */\n+    private int mTouchState = TOUCH_STATE_REST;\n+    /**\n+     * 记录被判定为滚动运动的最小滚动值\n+     */\n+    private int mTouchSlop;\n+    /**\n+     * 记录控件高度\n+     */\n+    private int mHeight;\n+    /**\n+     * 记录每张图片的宽度\n+     */\n+    private int mImageWidth;\n+    /**\n+     * 记录图片的总数量\n+     */\n+    private int mCount;\n+    /**\n+     * 记录当前显示图片的坐标\n+     */\n+    private int mCurrentImage;\n+    /**\n+     * 记录上次触摸的横坐标值\n+     */\n+    private float mLastMotionX;\n+    /**\n+     * 是否强制重新布局\n+     */\n+    private boolean forceToRelayout;\n+    private int[] mItems;\n \n-\t/**\n-\t * 图片左右两边的空白间距\n-\t */\n-\tpublic static final int IMAGE_PADDING = 10;\n-\tprivate static final int TOUCH_STATE_REST = 0;\n-\tprivate static final int TOUCH_STATE_SCROLLING = 1;\n-\t/**\n-\t * 滚动到下一张图片的速度\n-\t */\n-\tprivate static final int SNAP_VELOCITY = 600;\n-\t/**\n-\t * 表示滚动到下一张图片这个动作\n-\t */\n-\tprivate static final int SCROLL_NEXT = 0;\n-\t/**\n-\t * 表示滚动到上一张图片这个动作\n-\t */\n-\tprivate static final int SCROLL_PREVIOUS = 1;\n-\t/**\n-\t * 表示滚动回原图片这个动作\n-\t */\n-\tprivate static final int SCROLL_BACK = 2;\n-\tprivate static Handler handler = new Handler();\n-\t/**\n-\t * 控件宽度\n-\t */\n-\tpublic static int mWidth;\n-\tprivate VelocityTracker mVelocityTracker;\n-\tprivate Scroller mScroller;\n-\t/**\n-\t * 图片滚动监听器，当图片发生滚动时回调这个接口\n-\t */\n-\tprivate OnImageSwitchListener mListener;\n-\t/**\n-\t * 记录当前的触摸状态\n-\t */\n-\tprivate int mTouchState = TOUCH_STATE_REST;\n-\t/**\n-\t * 记录被判定为滚动运动的最小滚动值\n-\t */\n-\tprivate int mTouchSlop;\n-\t/**\n-\t * 记录控件高度\n-\t */\n-\tprivate int mHeight;\n-\t/**\n-\t * 记录每张图片的宽度\n-\t */\n-\tprivate int mImageWidth;\n-\t/**\n-\t * 记录图片的总数量\n-\t */\n-\tprivate int mCount;\n-\t/**\n-\t * 记录当前显示图片的坐标\n-\t */\n-\tprivate int mCurrentImage;\n-\t/**\n-\t * 记录上次触摸的横坐标值\n-\t */\n-\tprivate float mLastMotionX;\n-\t/**\n-\t * 是否强制重新布局\n-\t */\n-\tprivate boolean forceToRelayout;\n-\tprivate int[] mItems;\n+    public Net1314080903203Image3DSwitchView(Context context, AttributeSet attrs) {\n+        super(context, attrs);\n+        mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();\n+        mScroller = new Scroller(context);\n+    }\n \n-\tpublic Net1314080903203Image3DSwitchView(Context context, AttributeSet attrs) {\n-\t\tsuper(context, attrs);\n-\t\tmTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();\n-\t\tmScroller = new Scroller(context);\n-\t}\n+    @Override\n+    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n+        if (changed || forceToRelayout) {\n+            mCount = getChildCount();\n+            // 图片数量必须大于5，不然无法正常显示\n+            if (mCount < 5) {\n+                return;\n+            }\n+            mWidth = getMeasuredWidth();\n+            mHeight = getMeasuredHeight();\n+            // 每张图片的宽度设定为控件宽度的百分之六十\n+            mImageWidth = (int) (mWidth * 0.6);\n+            if (mCurrentImage >= 0 && mCurrentImage < mCount) {\n+                mScroller.abortAnimation();\n+                setScrollX(0);\n+                int left = -mImageWidth * 2 + (mWidth - mImageWidth) / 2;\n+                // 分别获取每个位置上应该显示的图片下标\n+                int[] items = { getIndexForItem(1), getIndexForItem(2),\n+                        getIndexForItem(3), getIndexForItem(4),\n+                        getIndexForItem(5) };\n+                mItems = items;\n+                // 通过循环为每张图片设定位置\n+                for (int i = 0; i < items.length; i++) {\n+                    Net1314080903203Image3DView childView = (Net1314080903203Image3DView) getChildAt(items[i]);\n+                    childView.layout(left + IMAGE_PADDING, 0, left\n+                            + mImageWidth - IMAGE_PADDING, mHeight);\n+                    childView.initImageViewBitmap();\n+                    left = left + mImageWidth;\n+                }\n+                refreshImageShowing();\n+            }\n+            forceToRelayout = false;\n+        }\n+    }\n \n-\t@Override\n-\tprotected void onLayout(boolean changed, int l, int t, int r, int b) {\n-\t\tif (changed || forceToRelayout) {\n-\t\t\tmCount = getChildCount();\n-\t\t\t// 图片数量必须大于5，不然无法正常显示\n-\t\t\tif (mCount < 5) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tmWidth = getMeasuredWidth();\n-\t\t\tmHeight = getMeasuredHeight();\n-\t\t\t// 每张图片的宽度设定为控件宽度的百分之六十\n-\t\t\tmImageWidth = (int) (mWidth * 0.6);\n-\t\t\tif (mCurrentImage >= 0 && mCurrentImage < mCount) {\n-\t\t\t\tmScroller.abortAnimation();\n-\t\t\t\tsetScrollX(0);\n-\t\t\t\tint left = -mImageWidth * 2 + (mWidth - mImageWidth) / 2;\n-\t\t\t\t// 分别获取每个位置上应该显示的图片下标\n-\t\t\t\tint[] items = { getIndexForItem(1), getIndexForItem(2),\n-\t\t\t\t\t\tgetIndexForItem(3), getIndexForItem(4),\n-\t\t\t\t\t\tgetIndexForItem(5) };\n-\t\t\t\tmItems = items;\n-\t\t\t\t// 通过循环为每张图片设定位置\n-\t\t\t\tfor (int i = 0; i < items.length; i++) {\n-\t\t\t\t\tImage3DView childView = (Image3DView) getChildAt(items[i]);\n-\t\t\t\t\tchildView.layout(left + IMAGE_PADDING, 0, left\n-\t\t\t\t\t\t\t+ mImageWidth - IMAGE_PADDING, mHeight);\n-\t\t\t\t\tchildView.initImageViewBitmap();\n-\t\t\t\t\tleft = left + mImageWidth;\n-\t\t\t\t}\n-\t\t\t\trefreshImageShowing();\n-\t\t\t}\n-\t\t\tforceToRelayout = false;\n-\t\t}\n-\t}\n \n-\t@Override\n-\tpublic boolean onTouchEvent(MotionEvent event) {\n-\t\tif (mScroller.isFinished()) {\n-\t\t\tif (mVelocityTracker == null) {\n-\t\t\t\tmVelocityTracker = VelocityTracker.obtain();\n-\t\t\t}\n-\t\t\tmVelocityTracker.addMovement(event);\n-\t\t\tint action = event.getAction();\n-\t\t\tfloat x = event.getX();\n-\t\t\tswitch (action) {\n-\t\t\tcase MotionEvent.ACTION_DOWN:\n-\t\t\t\t// 记录按下时的横坐标\n-\t\t\t\tmLastMotionX = x;\n-\t\t\t\tbreak;\n-\t\t\tcase MotionEvent.ACTION_MOVE:\n-\t\t\t\tint disX = (int) (mLastMotionX - x);\n-\t\t\t\tmLastMotionX = x;\n-\t\t\t\tscrollBy(disX, 0);\n-\t\t\t\t// 当发生移动时刷新图片的显示状态\n-\t\t\t\trefreshImageShowing();\n-\t\t\t\tbreak;\n-\t\t\tcase MotionEvent.ACTION_UP:\n-\t\t\t\tmVelocityTracker.computeCurrentVelocity(1000);\n-\t\t\t\tint velocityX = (int) mVelocityTracker.getXVelocity();\n-\t\t\t\tif (shouldScrollToNext(velocityX)) {\n-\t\t\t\t\t// 滚动到下一张图\n-\t\t\t\t\tscrollToNext();\n-\t\t\t\t} else if (shouldScrollToPrevious(velocityX)) {\n-\t\t\t\t\t// 滚动到上一张图\n-\t\t\t\t\tscrollToPrevious();\n-\t\t\t\t} else {\n-\t\t\t\t\t// 滚动回当前图片\n-\t\t\t\t\tscrollBack();\n-\t\t\t\t}\n-\t\t\t\tif (mVelocityTracker != null) {\n-\t\t\t\t\tmVelocityTracker.recycle();\n-\t\t\t\t\tmVelocityTracker = null;\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn true;\n-\t}\n \n-\t/**\n-\t * 根据当前的触摸状态来决定是否屏蔽子控件的交互能力。\n-\t */\n-\t@Override\n-\tpublic boolean onInterceptTouchEvent(MotionEvent ev) {\n-\t\tint action = ev.getAction();\n-\t\tif ((action == MotionEvent.ACTION_MOVE)\n-\t\t\t\t&& (mTouchState != TOUCH_STATE_REST)) {\n-\t\t\treturn true;\n-\t\t}\n-\t\tfloat x = ev.getX();\n-\t\tswitch (action) {\n-\t\tcase MotionEvent.ACTION_DOWN:\n-\t\t\tmLastMotionX = x;\n-\t\t\tmTouchState = TOUCH_STATE_REST;\n-\t\t\tbreak;\n-\t\tcase MotionEvent.ACTION_MOVE:\n-\t\t\tint xDiff = (int) Math.abs(mLastMotionX - x);\n-\t\t\tif (xDiff > mTouchSlop) {\n-\t\t\t\tmTouchState = TOUCH_STATE_SCROLLING;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase MotionEvent.ACTION_UP:\n-\t\tdefault:\n-\t\t\tmTouchState = TOUCH_STATE_REST;\n-\t\t\tbreak;\n-\t\t}\n-\t\treturn mTouchState != TOUCH_STATE_REST;\n-\t}\n+    @Override\n+    public boolean onTouchEvent(MotionEvent event) {\n+        if (mScroller.isFinished()) {\n+            if (mVelocityTracker == null) {\n+                mVelocityTracker = VelocityTracker.obtain();\n+            }\n+            mVelocityTracker.addMovement(event);\n+            int action = event.getAction();\n+            float x = event.getX();\n+            switch (action) {\n+                case MotionEvent.ACTION_DOWN:\n+                    // 记录按下时的横坐标\n+                    mLastMotionX = x;\n+                    break;\n+                case MotionEvent.ACTION_MOVE:\n+                    int disX = (int) (mLastMotionX - x);\n+                    mLastMotionX = x;\n+                    scrollBy(disX, 0);\n+                    // 当发生移动时刷新图片的显示状态\n+                    refreshImageShowing();\n+                    break;\n+                case MotionEvent.ACTION_UP:\n+                    mVelocityTracker.computeCurrentVelocity(1000);\n+                    int velocityX = (int) mVelocityTracker.getXVelocity();\n+                    if (shouldScrollToNext(velocityX)) {\n+                        // 滚动到下一张图\n+                        scrollToNext();\n+                    } else if (shouldScrollToPrevious(velocityX)) {\n+                        // 滚动到上一张图\n+                        scrollToPrevious();\n+                    } else {\n+                        // 滚动回当前图片\n+                        scrollBack();\n+                    }\n+                    if (mVelocityTracker != null) {\n+                        mVelocityTracker.recycle();\n+                        mVelocityTracker = null;\n+                    }\n+                    break;\n+            }\n+        }\n+        return true;\n+    }\n \n-\t@Override\n-\tpublic void computeScroll() {\n-\t\tif (mScroller.computeScrollOffset()) {\n-\t\t\tscrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n-\t\t\trefreshImageShowing();\n-\t\t\tpostInvalidate();\n-\t\t}\n-\t}\n+    /**\n+     * 根据当前的触摸状态来决定是否屏蔽子控件的交互能力。\n+     */\n+    @Override\n+    public boolean onInterceptTouchEvent(MotionEvent ev) {\n+        int action = ev.getAction();\n+        if ((action == MotionEvent.ACTION_MOVE)\n+                && (mTouchState != TOUCH_STATE_REST)) {\n+            return true;\n+        }\n+        float x = ev.getX();\n+        switch (action) {\n+            case MotionEvent.ACTION_DOWN:\n+                mLastMotionX = x;\n+                mTouchState = TOUCH_STATE_REST;\n+                break;\n+            case MotionEvent.ACTION_MOVE:\n+                int xDiff = (int) Math.abs(mLastMotionX - x);\n+                if (xDiff > mTouchSlop) {\n+                    mTouchState = TOUCH_STATE_SCROLLING;\n+                }\n+                break;\n+            case MotionEvent.ACTION_UP:\n+            default:\n+                mTouchState = TOUCH_STATE_REST;\n+                break;\n+        }\n+        return mTouchState != TOUCH_STATE_REST;\n+    }\n \n-\t/**\n-\t * 设置图片滚动的监听器，每当有图片滚动时会回调此接口。\n-\t * \n-\t * @param listener\n-\t *            图片滚动监听器\n-\t */\n-\tpublic void setOnImageSwitchListener(OnImageSwitchListener listener) {\n-\t\tmListener = listener;\n-\t}\n+    @Override\n+    public void computeScroll() {\n+        if (mScroller.computeScrollOffset()) {\n+            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n+            refreshImageShowing();\n+            postInvalidate();\n+        }\n+    }\n \n-\t/**\n-\t * 设置当前显示图片的下标，注意如果该值小于零或大于等于图片的总数量，图片则无法正常显示。\n-\t * \n-\t * @param currentImage\n-\t *            图片的下标\n-\t */\n-\tpublic void setCurrentImage(int currentImage) {\n-\t\tmCurrentImage = currentImage;\n-\t\trequestLayout();\n-\t}\n+    /**\n+     * 设置图片滚动的监听器，每当有图片滚动时会回调此接口。\n+     *\n+     * @param listener\n+     *            图片滚动监听器\n+     */\n+    public void setOnImageSwitchListener(OnImageSwitchListener listener) {\n+        mListener = listener;\n+    }\n \n-\t/**\n-\t * 滚动到下一张图片。\n-\t */\n-\tpublic void scrollToNext() {\n-\t\tif (mScroller.isFinished()) {\n-\t\t\tint disX = mImageWidth - getScrollX();\n-\t\t\tcheckImageSwitchBorder(SCROLL_NEXT);\n-\t\t\tif (mListener != null) {\n-\t\t\t\tmListener.onImageSwitch(mCurrentImage);\n-\t\t\t}\n-\t\t\tbeginScroll(getScrollX(), 0, disX, 0, SCROLL_NEXT);\n-\t\t}\n-\t}\n+    /**\n+     * 设置当前显示图片的下标，注意如果该值小于零或大于等于图片的总数量，图片则无法正常显示。\n+     *\n+     * @param currentImage\n+     *            图片的下标\n+     */\n+    public void setCurrentImage(int currentImage) {\n+        mCurrentImage = currentImage;\n+        requestLayout();\n+    }\n \n-\t/**\n-\t * 滚动到上一张图片。\n-\t */\n-\tpublic void scrollToPrevious() {\n-\t\tif (mScroller.isFinished()) {\n-\t\t\tint disX = -mImageWidth - getScrollX();\n-\t\t\tcheckImageSwitchBorder(SCROLL_PREVIOUS);\n-\t\t\tif (mListener != null) {\n-\t\t\t\tmListener.onImageSwitch(mCurrentImage);\n-\t\t\t}\n-\t\t\tbeginScroll(getScrollX(), 0, disX, 0, SCROLL_PREVIOUS);\n-\t\t}\n-\t}\n+    /**\n+     * 滚动到下一张图片。\n+     */\n+    public void scrollToNext() {\n+        if (mScroller.isFinished()) {\n+            int disX = mImageWidth - getScrollX();\n+            checkImageSwitchBorder(SCROLL_NEXT);\n+            if (mListener != null) {\n+                mListener.onImageSwitch(mCurrentImage);\n+            }\n+            beginScroll(getScrollX(), 0, disX, 0, SCROLL_NEXT);\n+        }\n+    }\n \n-\t/**\n-\t * 滚动回原图片。\n-\t */\n-\tpublic void scrollBack() {\n-\t\tif (mScroller.isFinished()) {\n-\t\t\tbeginScroll(getScrollX(), 0, -getScrollX(), 0, SCROLL_BACK);\n-\t\t}\n-\t}\n+    /**\n+     * 滚动到上一张图片。\n+     */\n+    public void scrollToPrevious() {\n+        if (mScroller.isFinished()) {\n+            int disX = -mImageWidth - getScrollX();\n+            checkImageSwitchBorder(SCROLL_PREVIOUS);\n+            if (mListener != null) {\n+                mListener.onImageSwitch(mCurrentImage);\n+            }\n+            beginScroll(getScrollX(), 0, disX, 0, SCROLL_PREVIOUS);\n+        }\n+    }\n \n-\t/**\n-\t * 回收所有图片对象，释放内存。\n-\t */\n-\tpublic void clear() {\n-\t\tfor (int i = 0; i < mCount; i++) {\n-\t\t\tImage3DView childView = (Image3DView) getChildAt(i);\n-\t\t\tchildView.recycleBitmap();\n-\t\t}\n-\t}\n+    /**\n+     * 滚动回原图片。\n+     */\n+    public void scrollBack() {\n+        if (mScroller.isFinished()) {\n+            beginScroll(getScrollX(), 0, -getScrollX(), 0, SCROLL_BACK);\n+        }\n+    }\n \n-\t/**\n-\t * 让控件中的所有图片开始滚动。\n-\t */\n-\tprivate void beginScroll(int startX, int startY, int dx, int dy,\n-\t\t\tfinal int action) {\n-\t\tint duration = (int) (700f / mImageWidth * Math.abs(dx));\n-\t\tmScroller.startScroll(startX, startY, dx, dy, duration);\n-\t\tinvalidate();\n-\t\thandler.postDelayed(new Runnable() {\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tif (action == SCROLL_NEXT || action == SCROLL_PREVIOUS) {\n-\t\t\t\t\tforceToRelayout = true;\n-\t\t\t\t\trequestLayout();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}, duration);\n-\t}\n+    /**\n+     * 回收所有图片对象，释放内存。\n+     */\n+    public void clear() {\n+        for (int i = 0; i < mCount; i++) {\n+            Net1314080903203Image3DView childView = (Net1314080903203Image3DView) getChildAt(i);\n+            childView.recycleBitmap();\n+        }\n+    }\n \n-\t/**\n-\t * 根据当前图片的下标和传入的item参数，来判断item位置上应该显示哪张图片。\n-\t * \n-\t * @param item\n-\t *            取值范围是1-5\n-\t * @return 对应item位置上应该显示哪张图片。\n-\t */\n-\tprivate int getIndexForItem(int item) {\n-\t\tint index = -1;\n-\t\tindex = mCurrentImage + item - 3;\n-\t\twhile (index < 0) {\n-\t\t\tindex = index + mCount;\n-\t\t}\n-\t\twhile (index > mCount - 1) {\n-\t\t\tindex = index - mCount;\n-\t\t}\n-\t\treturn index;\n-\t}\n+    /**\n+     * 让控件中的所有图片开始滚动。\n+     */\n+    private void beginScroll(int startX, int startY, int dx, int dy,\n+                             final int action) {\n+        int duration = (int) (700f / mImageWidth * Math.abs(dx));\n+        mScroller.startScroll(startX, startY, dx, dy, duration);\n+        invalidate();\n+        handler.postDelayed(new Runnable() {\n+            @Override\n+            public void run() {\n+                if (action == SCROLL_NEXT || action == SCROLL_PREVIOUS) {\n+                    forceToRelayout = true;\n+                    requestLayout();\n+                }\n+            }\n+        }, duration);\n+    }\n \n-\t/**\n-\t * 刷新所有图片的显示状态，包括当前的旋转角度。\n-\t */\n-\tprivate void refreshImageShowing() {\n-\t\tfor (int i = 0; i < mItems.length; i++) {\n-\t\t\tImage3DView childView = (Image3DView) getChildAt(mItems[i]);\n-\t\t\tchildView.setRotateData(i, getScrollX());\n-\t\t\tchildView.invalidate();\n-\t\t}\n-\t}\n+    /**\n+     * 根据当前图片的下标和传入的item参数，来判断item位置上应该显示哪张图片。\n+     *\n+     * @param item\n+     *            取值范围是1-5\n+     * @return 对应item位置上应该显示哪张图片。\n+     */\n+    private int getIndexForItem(int item) {\n+        int index = -1;\n+        index = mCurrentImage + item - 3;\n+        while (index < 0) {\n+            index = index + mCount;\n+        }\n+        while (index > mCount - 1) {\n+            index = index - mCount;\n+        }\n+        return index;\n+    }\n \n-\t/**\n-\t * 检查图片的边界，防止图片的下标超出规定范围。\n-\t */\n-\tprivate void checkImageSwitchBorder(int action) {\n-\t\tif (action == SCROLL_NEXT && ++mCurrentImage >= mCount) {\n-\t\t\tmCurrentImage = 0;\n-\t\t} else if (action == SCROLL_PREVIOUS && --mCurrentImage < 0) {\n-\t\t\tmCurrentImage = mCount - 1;\n-\t\t}\n-\t}\n+    /**\n+     * 刷新所有图片的显示状态，包括当前的旋转角度。\n+     */\n+    private void refreshImageShowing() {\n+        for (int i = 0; i < mItems.length; i++) {\n+            Net1314080903203Image3DView childView = (Net1314080903203Image3DView) getChildAt(mItems[i]);\n+            childView.setRotateData(i, getScrollX());\n+            childView.invalidate();\n+        }\n+    }\n \n-\t/**\n-\t * 判断是否应该滚动到下一张图片。\n-\t */\n-\tprivate boolean shouldScrollToNext(int velocityX) {\n-\t\treturn velocityX < -SNAP_VELOCITY || getScrollX() > mImageWidth / 2;\n-\t}\n+    /**\n+     * 检查图片的边界，防止图片的下标超出规定范围。\n+     */\n+    private void checkImageSwitchBorder(int action) {\n+        if (action == SCROLL_NEXT && ++mCurrentImage >= mCount) {\n+            mCurrentImage = 0;\n+        } else if (action == SCROLL_PREVIOUS && --mCurrentImage < 0) {\n+            mCurrentImage = mCount - 1;\n+        }\n+    }\n \n-\t/**\n-\t * 判断是否应该滚动到上一张图片。\n-\t */\n-\tprivate boolean shouldScrollToPrevious(int velocityX) {\n-\t\treturn velocityX > SNAP_VELOCITY || getScrollX() < -mImageWidth / 2;\n-\t}\n+    /**\n+     * 判断是否应该滚动到下一张图片。\n+     */\n+    private boolean shouldScrollToNext(int velocityX) {\n+        return velocityX < -SNAP_VELOCITY || getScrollX() > mImageWidth / 2;\n+    }\n \n-\t/**\n-\t * 图片滚动的监听器\n-\t */\n-\tpublic interface OnImageSwitchListener {\n+    /**\n+     * 判断是否应该滚动到上一张图片。\n+     */\n+    private boolean shouldScrollToPrevious(int velocityX) {\n+        return velocityX > SNAP_VELOCITY || getScrollX() < -mImageWidth / 2;\n+    }\n \n-\t\t/**\n-\t\t * 当图片滚动时会回调此方法\n-\t\t * \n-\t\t * @param currentImage\n-\t\t *            当前图片的坐标\n-\t\t */\n-\t\tvoid onImageSwitch(int currentImage);\n+    /**\n+     * 图片滚动的监听器\n+     */\n+    public interface OnImageSwitchListener {\n \n-\t}\n-}\n\\ No newline at end of file\n+        /**\n+         * 当图片滚动时会回调此方法\n+         *\n+         * @param currentImage\n+         *            当前图片的坐标\n+         */\n+        void onImageSwitch(int currentImage);\n+\n+    }\n+}"
  } ],
  "sha" : "d05600f6fdd73036ed0b751fd7727328c84d9a03",
  "url" : "https://api.github.com/repos/hzuapps/android-labs/commits/d05600f6fdd73036ed0b751fd7727328c84d9a03",
  "parents" : [ {
    "sha" : "7e61b16f012527dc1d999c9d6e28e968b05e5344",
    "url" : "https://api.github.com/repos/hzuapps/android-labs/commits/7e61b16f012527dc1d999c9d6e28e968b05e5344",
    "html_url" : "https://github.com/hzuapps/android-labs/commit/7e61b16f012527dc1d999c9d6e28e968b05e5344"
  } ]
}