{
  "committer" : null,
  "stats" : {
    "total" : 677,
    "additions" : 677,
    "deletions" : 0
  },
  "author" : null,
  "html_url" : "https://github.com/hzuapps/android-labs/commit/f96ca14dc2ac6390a5bf84b9c2216dbbcc86a16e",
  "commit" : {
    "author" : {
      "name" : "unknown",
      "email" : "陈聪",
      "date" : "2016-04-20T05:40:31Z"
    },
    "committer" : {
      "name" : "unknown",
      "email" : "陈聪",
      "date" : "2016-04-20T05:40:31Z"
    },
    "message" : "#88 #122 重新提交实验2代码",
    "tree" : {
      "sha" : "7ce0588bab4f5cab0ded0162956319faf3fb242c",
      "url" : "https://api.github.com/repos/hzuapps/android-labs/git/trees/7ce0588bab4f5cab0ded0162956319faf3fb242c"
    },
    "url" : "https://api.github.com/repos/hzuapps/android-labs/git/commits/f96ca14dc2ac6390a5bf84b9c2216dbbcc86a16e",
    "comment_count" : 0
  },
  "comments_url" : "https://api.github.com/repos/hzuapps/android-labs/commits/f96ca14dc2ac6390a5bf84b9c2216dbbcc86a16e/comments",
  "files" : [ {
    "sha" : "9153539c0a75734411b27b610c36553267fa1f14",
    "filename" : "app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DSwitchView.java",
    "status" : "added",
    "additions" : 365,
    "deletions" : 0,
    "changes" : 365,
    "blob_url" : "https://github.com/hzuapps/android-labs/blob/f96ca14dc2ac6390a5bf84b9c2216dbbcc86a16e/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DSwitchView.java",
    "raw_url" : "https://github.com/hzuapps/android-labs/raw/f96ca14dc2ac6390a5bf84b9c2216dbbcc86a16e/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DSwitchView.java",
    "contents_url" : "https://api.github.com/repos/hzuapps/android-labs/contents/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DSwitchView.java?ref=f96ca14dc2ac6390a5bf84b9c2216dbbcc86a16e",
    "patch" : "@@ -0,0 +1,365 @@\n+﻿package com.example.imageswitchviewtest;\n+\n+import android.content.Context;\n+import android.os.Handler;\n+import android.util.AttributeSet;\n+import android.view.MotionEvent;\n+import android.view.VelocityTracker;\n+import android.view.ViewConfiguration;\n+import android.view.ViewGroup;\n+import android.widget.Scroller;\n+\n+/**\n+ * 3D图片轮播器主控件。\n+ * \n+ */\n+public class Net1314080903203Image3DSwitchView extends ViewGroup {\n+\n+\t/**\n+\t * 图片左右两边的空白间距\n+\t */\n+\tpublic static final int IMAGE_PADDING = 10;\n+\tprivate static final int TOUCH_STATE_REST = 0;\n+\tprivate static final int TOUCH_STATE_SCROLLING = 1;\n+\t/**\n+\t * 滚动到下一张图片的速度\n+\t */\n+\tprivate static final int SNAP_VELOCITY = 600;\n+\t/**\n+\t * 表示滚动到下一张图片这个动作\n+\t */\n+\tprivate static final int SCROLL_NEXT = 0;\n+\t/**\n+\t * 表示滚动到上一张图片这个动作\n+\t */\n+\tprivate static final int SCROLL_PREVIOUS = 1;\n+\t/**\n+\t * 表示滚动回原图片这个动作\n+\t */\n+\tprivate static final int SCROLL_BACK = 2;\n+\tprivate static Handler handler = new Handler();\n+\t/**\n+\t * 控件宽度\n+\t */\n+\tpublic static int mWidth;\n+\tprivate VelocityTracker mVelocityTracker;\n+\tprivate Scroller mScroller;\n+\t/**\n+\t * 图片滚动监听器，当图片发生滚动时回调这个接口\n+\t */\n+\tprivate OnImageSwitchListener mListener;\n+\t/**\n+\t * 记录当前的触摸状态\n+\t */\n+\tprivate int mTouchState = TOUCH_STATE_REST;\n+\t/**\n+\t * 记录被判定为滚动运动的最小滚动值\n+\t */\n+\tprivate int mTouchSlop;\n+\t/**\n+\t * 记录控件高度\n+\t */\n+\tprivate int mHeight;\n+\t/**\n+\t * 记录每张图片的宽度\n+\t */\n+\tprivate int mImageWidth;\n+\t/**\n+\t * 记录图片的总数量\n+\t */\n+\tprivate int mCount;\n+\t/**\n+\t * 记录当前显示图片的坐标\n+\t */\n+\tprivate int mCurrentImage;\n+\t/**\n+\t * 记录上次触摸的横坐标值\n+\t */\n+\tprivate float mLastMotionX;\n+\t/**\n+\t * 是否强制重新布局\n+\t */\n+\tprivate boolean forceToRelayout;\n+\tprivate int[] mItems;\n+\n+\tpublic Net1314080903203Image3DSwitchView(Context context, AttributeSet attrs) {\n+\t\tsuper(context, attrs);\n+\t\tmTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();\n+\t\tmScroller = new Scroller(context);\n+\t}\n+\n+\t@Override\n+\tprotected void onLayout(boolean changed, int l, int t, int r, int b) {\n+\t\tif (changed || forceToRelayout) {\n+\t\t\tmCount = getChildCount();\n+\t\t\t// 图片数量必须大于5，不然无法正常显示\n+\t\t\tif (mCount < 5) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tmWidth = getMeasuredWidth();\n+\t\t\tmHeight = getMeasuredHeight();\n+\t\t\t// 每张图片的宽度设定为控件宽度的百分之六十\n+\t\t\tmImageWidth = (int) (mWidth * 0.6);\n+\t\t\tif (mCurrentImage >= 0 && mCurrentImage < mCount) {\n+\t\t\t\tmScroller.abortAnimation();\n+\t\t\t\tsetScrollX(0);\n+\t\t\t\tint left = -mImageWidth * 2 + (mWidth - mImageWidth) / 2;\n+\t\t\t\t// 分别获取每个位置上应该显示的图片下标\n+\t\t\t\tint[] items = { getIndexForItem(1), getIndexForItem(2),\n+\t\t\t\t\t\tgetIndexForItem(3), getIndexForItem(4),\n+\t\t\t\t\t\tgetIndexForItem(5) };\n+\t\t\t\tmItems = items;\n+\t\t\t\t// 通过循环为每张图片设定位置\n+\t\t\t\tfor (int i = 0; i < items.length; i++) {\n+\t\t\t\t\tImage3DView childView = (Image3DView) getChildAt(items[i]);\n+\t\t\t\t\tchildView.layout(left + IMAGE_PADDING, 0, left\n+\t\t\t\t\t\t\t+ mImageWidth - IMAGE_PADDING, mHeight);\n+\t\t\t\t\tchildView.initImageViewBitmap();\n+\t\t\t\t\tleft = left + mImageWidth;\n+\t\t\t\t}\n+\t\t\t\trefreshImageShowing();\n+\t\t\t}\n+\t\t\tforceToRelayout = false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean onTouchEvent(MotionEvent event) {\n+\t\tif (mScroller.isFinished()) {\n+\t\t\tif (mVelocityTracker == null) {\n+\t\t\t\tmVelocityTracker = VelocityTracker.obtain();\n+\t\t\t}\n+\t\t\tmVelocityTracker.addMovement(event);\n+\t\t\tint action = event.getAction();\n+\t\t\tfloat x = event.getX();\n+\t\t\tswitch (action) {\n+\t\t\tcase MotionEvent.ACTION_DOWN:\n+\t\t\t\t// 记录按下时的横坐标\n+\t\t\t\tmLastMotionX = x;\n+\t\t\t\tbreak;\n+\t\t\tcase MotionEvent.ACTION_MOVE:\n+\t\t\t\tint disX = (int) (mLastMotionX - x);\n+\t\t\t\tmLastMotionX = x;\n+\t\t\t\tscrollBy(disX, 0);\n+\t\t\t\t// 当发生移动时刷新图片的显示状态\n+\t\t\t\trefreshImageShowing();\n+\t\t\t\tbreak;\n+\t\t\tcase MotionEvent.ACTION_UP:\n+\t\t\t\tmVelocityTracker.computeCurrentVelocity(1000);\n+\t\t\t\tint velocityX = (int) mVelocityTracker.getXVelocity();\n+\t\t\t\tif (shouldScrollToNext(velocityX)) {\n+\t\t\t\t\t// 滚动到下一张图\n+\t\t\t\t\tscrollToNext();\n+\t\t\t\t} else if (shouldScrollToPrevious(velocityX)) {\n+\t\t\t\t\t// 滚动到上一张图\n+\t\t\t\t\tscrollToPrevious();\n+\t\t\t\t} else {\n+\t\t\t\t\t// 滚动回当前图片\n+\t\t\t\t\tscrollBack();\n+\t\t\t\t}\n+\t\t\t\tif (mVelocityTracker != null) {\n+\t\t\t\t\tmVelocityTracker.recycle();\n+\t\t\t\t\tmVelocityTracker = null;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * 根据当前的触摸状态来决定是否屏蔽子控件的交互能力。\n+\t */\n+\t@Override\n+\tpublic boolean onInterceptTouchEvent(MotionEvent ev) {\n+\t\tint action = ev.getAction();\n+\t\tif ((action == MotionEvent.ACTION_MOVE)\n+\t\t\t\t&& (mTouchState != TOUCH_STATE_REST)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tfloat x = ev.getX();\n+\t\tswitch (action) {\n+\t\tcase MotionEvent.ACTION_DOWN:\n+\t\t\tmLastMotionX = x;\n+\t\t\tmTouchState = TOUCH_STATE_REST;\n+\t\t\tbreak;\n+\t\tcase MotionEvent.ACTION_MOVE:\n+\t\t\tint xDiff = (int) Math.abs(mLastMotionX - x);\n+\t\t\tif (xDiff > mTouchSlop) {\n+\t\t\t\tmTouchState = TOUCH_STATE_SCROLLING;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase MotionEvent.ACTION_UP:\n+\t\tdefault:\n+\t\t\tmTouchState = TOUCH_STATE_REST;\n+\t\t\tbreak;\n+\t\t}\n+\t\treturn mTouchState != TOUCH_STATE_REST;\n+\t}\n+\n+\t@Override\n+\tpublic void computeScroll() {\n+\t\tif (mScroller.computeScrollOffset()) {\n+\t\t\tscrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n+\t\t\trefreshImageShowing();\n+\t\t\tpostInvalidate();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * 设置图片滚动的监听器，每当有图片滚动时会回调此接口。\n+\t * \n+\t * @param listener\n+\t *            图片滚动监听器\n+\t */\n+\tpublic void setOnImageSwitchListener(OnImageSwitchListener listener) {\n+\t\tmListener = listener;\n+\t}\n+\n+\t/**\n+\t * 设置当前显示图片的下标，注意如果该值小于零或大于等于图片的总数量，图片则无法正常显示。\n+\t * \n+\t * @param currentImage\n+\t *            图片的下标\n+\t */\n+\tpublic void setCurrentImage(int currentImage) {\n+\t\tmCurrentImage = currentImage;\n+\t\trequestLayout();\n+\t}\n+\n+\t/**\n+\t * 滚动到下一张图片。\n+\t */\n+\tpublic void scrollToNext() {\n+\t\tif (mScroller.isFinished()) {\n+\t\t\tint disX = mImageWidth - getScrollX();\n+\t\t\tcheckImageSwitchBorder(SCROLL_NEXT);\n+\t\t\tif (mListener != null) {\n+\t\t\t\tmListener.onImageSwitch(mCurrentImage);\n+\t\t\t}\n+\t\t\tbeginScroll(getScrollX(), 0, disX, 0, SCROLL_NEXT);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * 滚动到上一张图片。\n+\t */\n+\tpublic void scrollToPrevious() {\n+\t\tif (mScroller.isFinished()) {\n+\t\t\tint disX = -mImageWidth - getScrollX();\n+\t\t\tcheckImageSwitchBorder(SCROLL_PREVIOUS);\n+\t\t\tif (mListener != null) {\n+\t\t\t\tmListener.onImageSwitch(mCurrentImage);\n+\t\t\t}\n+\t\t\tbeginScroll(getScrollX(), 0, disX, 0, SCROLL_PREVIOUS);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * 滚动回原图片。\n+\t */\n+\tpublic void scrollBack() {\n+\t\tif (mScroller.isFinished()) {\n+\t\t\tbeginScroll(getScrollX(), 0, -getScrollX(), 0, SCROLL_BACK);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * 回收所有图片对象，释放内存。\n+\t */\n+\tpublic void clear() {\n+\t\tfor (int i = 0; i < mCount; i++) {\n+\t\t\tImage3DView childView = (Image3DView) getChildAt(i);\n+\t\t\tchildView.recycleBitmap();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * 让控件中的所有图片开始滚动。\n+\t */\n+\tprivate void beginScroll(int startX, int startY, int dx, int dy,\n+\t\t\tfinal int action) {\n+\t\tint duration = (int) (700f / mImageWidth * Math.abs(dx));\n+\t\tmScroller.startScroll(startX, startY, dx, dy, duration);\n+\t\tinvalidate();\n+\t\thandler.postDelayed(new Runnable() {\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\tif (action == SCROLL_NEXT || action == SCROLL_PREVIOUS) {\n+\t\t\t\t\tforceToRelayout = true;\n+\t\t\t\t\trequestLayout();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}, duration);\n+\t}\n+\n+\t/**\n+\t * 根据当前图片的下标和传入的item参数，来判断item位置上应该显示哪张图片。\n+\t * \n+\t * @param item\n+\t *            取值范围是1-5\n+\t * @return 对应item位置上应该显示哪张图片。\n+\t */\n+\tprivate int getIndexForItem(int item) {\n+\t\tint index = -1;\n+\t\tindex = mCurrentImage + item - 3;\n+\t\twhile (index < 0) {\n+\t\t\tindex = index + mCount;\n+\t\t}\n+\t\twhile (index > mCount - 1) {\n+\t\t\tindex = index - mCount;\n+\t\t}\n+\t\treturn index;\n+\t}\n+\n+\t/**\n+\t * 刷新所有图片的显示状态，包括当前的旋转角度。\n+\t */\n+\tprivate void refreshImageShowing() {\n+\t\tfor (int i = 0; i < mItems.length; i++) {\n+\t\t\tImage3DView childView = (Image3DView) getChildAt(mItems[i]);\n+\t\t\tchildView.setRotateData(i, getScrollX());\n+\t\t\tchildView.invalidate();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * 检查图片的边界，防止图片的下标超出规定范围。\n+\t */\n+\tprivate void checkImageSwitchBorder(int action) {\n+\t\tif (action == SCROLL_NEXT && ++mCurrentImage >= mCount) {\n+\t\t\tmCurrentImage = 0;\n+\t\t} else if (action == SCROLL_PREVIOUS && --mCurrentImage < 0) {\n+\t\t\tmCurrentImage = mCount - 1;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * 判断是否应该滚动到下一张图片。\n+\t */\n+\tprivate boolean shouldScrollToNext(int velocityX) {\n+\t\treturn velocityX < -SNAP_VELOCITY || getScrollX() > mImageWidth / 2;\n+\t}\n+\n+\t/**\n+\t * 判断是否应该滚动到上一张图片。\n+\t */\n+\tprivate boolean shouldScrollToPrevious(int velocityX) {\n+\t\treturn velocityX > SNAP_VELOCITY || getScrollX() < -mImageWidth / 2;\n+\t}\n+\n+\t/**\n+\t * 图片滚动的监听器\n+\t */\n+\tpublic interface OnImageSwitchListener {\n+\n+\t\t/**\n+\t\t * 当图片滚动时会回调此方法\n+\t\t * \n+\t\t * @param currentImage\n+\t\t *            当前图片的坐标\n+\t\t */\n+\t\tvoid onImageSwitch(int currentImage);\n+\n+\t}\n+}\n\\ No newline at end of file"
  }, {
    "sha" : "057a717bfb15b0b559f6747c4e5df277409693e1",
    "filename" : "app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DView.java",
    "status" : "added",
    "additions" : 275,
    "deletions" : 0,
    "changes" : 275,
    "blob_url" : "https://github.com/hzuapps/android-labs/blob/f96ca14dc2ac6390a5bf84b9c2216dbbcc86a16e/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DView.java",
    "raw_url" : "https://github.com/hzuapps/android-labs/raw/f96ca14dc2ac6390a5bf84b9c2216dbbcc86a16e/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DView.java",
    "contents_url" : "https://api.github.com/repos/hzuapps/android-labs/contents/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203Image3DView.java?ref=f96ca14dc2ac6390a5bf84b9c2216dbbcc86a16e",
    "patch" : "@@ -0,0 +1,275 @@\n+﻿package com.example.imageswitchviewtest;\n+\n+import android.content.Context;\n+\n+import android.graphics.Bitmap;\n+import android.graphics.Camera;\n+import android.graphics.Canvas;\n+import android.graphics.Matrix;\n+import android.graphics.drawable.Drawable;\n+import android.net.Uri;\n+import android.util.AttributeSet;\n+import android.widget.ImageView;\n+\n+/**\n+ * 用于在Image3DSwitchView中显示3D图片。\n+ * \n+\n+ */\n+public class Net1314080903203Image3DView extends ImageView {\n+\t/**\n+\t * 旋转角度的基准值\n+\t */\n+\tprivate static final float BASE_DEGREE = 50f;\n+\t/**\n+\t * 旋转深度的基准值\n+\t */\n+\tprivate static final float BASE_DEEP = 150f;\n+\tprivate Camera mCamera;\n+\tprivate Matrix mMaxtrix;\n+\tprivate Bitmap mBitmap;\n+\t/**\n+\t * 当前图片对应的下标\n+\t */\n+\tprivate int mIndex;\n+\t/**\n+\t * 在前图片在X轴方向滚动的距离\n+\t */\n+\tprivate int mScrollX;\n+\t/**\n+\t * Image3DSwitchView控件的宽度\n+\t */\n+\tprivate int mLayoutWidth;\n+\t/**\n+\t * 当前图片的宽度\n+\t */\n+\tprivate int mWidth;\n+\t/**\n+\t * 当前旋转的角度\n+\t */\n+\tprivate float mRotateDegree;\n+\t/**\n+\t * 旋转的中心点\n+\t */\n+\tprivate float mDx;\n+\t/**\n+\t * 旋转的深度\n+\t */\n+\tprivate float mDeep;\n+\n+\tpublic Net1314080903203Image3DView(Context context, AttributeSet attrs) {\n+\t\tsuper(context, attrs);\n+\t\tmCamera = new Camera();\n+\t\tmMaxtrix = new Matrix();\n+\t}\n+\n+\t/**\n+\t * 初始化Image3DView所需要的信息，包括图片宽度，截取背景图等。\n+\t */\n+\tpublic void initImageViewBitmap() {\n+\t\tif (mBitmap == null) {\n+\t\t\tsetDrawingCacheEnabled(true);\n+\t\t\tbuildDrawingCache();\n+\t\t\tmBitmap = getDrawingCache();\n+\t\t}\n+\t\tmLayoutWidth = Image3DSwitchView.mWidth;\n+\t\tmWidth = getWidth() + Image3DSwitchView.IMAGE_PADDING * 2;\n+\t}\n+\n+\t/**\n+\t * 设置旋转角度。\n+\t * \n+\t * @param index\n+\t *            当前图片的下标\n+\t * @param scrollX\n+\t *            当前图片在X轴方向滚动的距离\n+\t */\n+\tpublic void setRotateData(int index, int scrollX) {\n+\t\tmIndex = index;\n+\t\tmScrollX = scrollX;\n+\t}\n+\n+\t/**\n+\t * 回收当前的Bitmap对象，以释放内存。\n+\t */\n+\tpublic void recycleBitmap() {\n+\t\tif (mBitmap != null && !mBitmap.isRecycled()) {\n+\t\t\tmBitmap.recycle();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void setImageResource(int resId) {\n+\t\tsuper.setImageResource(resId);\n+\t\tmBitmap = null;\n+\t\tinitImageViewBitmap();\n+\t}\n+\n+\t@Override\n+\tpublic void setImageBitmap(Bitmap bm) {\n+\t\tsuper.setImageBitmap(bm);\n+\t\tmBitmap = null;\n+\t\tinitImageViewBitmap();\n+\t}\n+\n+\t@Override\n+\tpublic void setImageDrawable(Drawable drawable) {\n+\t\tsuper.setImageDrawable(drawable);\n+\t\tmBitmap = null;\n+\t\tinitImageViewBitmap();\n+\t}\n+\n+\t@Override\n+\tpublic void setImageURI(Uri uri) {\n+\t\tsuper.setImageURI(uri);\n+\t\tmBitmap = null;\n+\t\tinitImageViewBitmap();\n+\t}\n+\n+\t@Override\n+\tprotected void onDraw(Canvas canvas) {\n+\t\tif (mBitmap == null) {\n+\t\t\t// 如果Bitmap对象还不存在，先使用父类的onDraw方法进行绘制\n+\t\t\tsuper.onDraw(canvas);\n+\t\t} else {\n+\t\t\tif (isImageVisible()) {\n+\t\t\t\t// 绘图时需要注意，只有当图片可见的时候才进行绘制，这样可以节省运算效率\n+\t\t\t\tcomputeRotateData();\n+\t\t\t\tmCamera.save();\n+\t\t\t\tmCamera.translate(0.0f, 0.0f, mDeep);\n+\t\t\t\tmCamera.rotateY(mRotateDegree);\n+\t\t\t\tmCamera.getMatrix(mMaxtrix);\n+\t\t\t\tmCamera.restore();\n+\t\t\t\tmMaxtrix.preTranslate(-mDx, -getHeight() / 2);\n+\t\t\t\tmMaxtrix.postTranslate(mDx, getHeight() / 2);\n+\t\t\t\tcanvas.drawBitmap(mBitmap, mMaxtrix, null);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * 在这里计算所有旋转所需要的数据。\n+\t */\n+\tprivate void computeRotateData() {\n+\t\tfloat degreePerPix = BASE_DEGREE / mWidth;\n+\t\tfloat deepPerPix = BASE_DEEP / ((mLayoutWidth - mWidth) / 2);\n+\t\tswitch (mIndex) {\n+\t\tcase 0:\n+\t\t\tmDx = mWidth;\n+\t\t\tmRotateDegree = 360f - (2 * mWidth + mScrollX) * degreePerPix;\n+\t\t\tif (mScrollX < -mWidth) {\n+\t\t\t\tmDeep = 0;\n+\t\t\t} else {\n+\t\t\t\tmDeep = (mWidth + mScrollX) * deepPerPix;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase 1:\n+\t\t\tif (mScrollX > 0) {\n+\t\t\t\tmDx = mWidth;\n+\t\t\t\tmRotateDegree = (360f - BASE_DEGREE) - mScrollX * degreePerPix;\n+\t\t\t\tmDeep = mScrollX * deepPerPix;\n+\t\t\t} else {\n+\t\t\t\tif (mScrollX < -mWidth) {\n+\t\t\t\t\tmDx = -Image3DSwitchView.IMAGE_PADDING * 2;\n+\t\t\t\t\tmRotateDegree = (-mScrollX - mWidth) * degreePerPix;\n+\t\t\t\t} else {\n+\t\t\t\t\tmDx = mWidth;\n+\t\t\t\t\tmRotateDegree = 360f - (mWidth + mScrollX) * degreePerPix;\n+\t\t\t\t}\n+\t\t\t\tmDeep = 0;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase 2:\n+\t\t\tif (mScrollX > 0) {\n+\t\t\t\tmDx = mWidth;\n+\t\t\t\tmRotateDegree = 360f - mScrollX * degreePerPix;\n+\t\t\t\tmDeep = 0;\n+\t\t\t\tif (mScrollX > mWidth) {\n+\t\t\t\t\tmDeep = (mScrollX - mWidth) * deepPerPix;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tmDx = -Image3DSwitchView.IMAGE_PADDING * 2;\n+\t\t\t\tmRotateDegree = -mScrollX * degreePerPix;\n+\t\t\t\tmDeep = 0;\n+\t\t\t\tif (mScrollX < -mWidth) {\n+\t\t\t\t\tmDeep = -(mWidth + mScrollX) * deepPerPix;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase 3:\n+\t\t\tif (mScrollX < 0) {\n+\t\t\t\tmDx = -Image3DSwitchView.IMAGE_PADDING * 2;\n+\t\t\t\tmRotateDegree = BASE_DEGREE - mScrollX * degreePerPix;\n+\t\t\t\tmDeep = -mScrollX * deepPerPix;\n+\t\t\t} else {\n+\t\t\t\tif (mScrollX > mWidth) {\n+\t\t\t\t\tmDx = mWidth;\n+\t\t\t\t\tmRotateDegree = 360f - (mScrollX - mWidth) * degreePerPix;\n+\t\t\t\t} else {\n+\t\t\t\t\tmDx = -Image3DSwitchView.IMAGE_PADDING * 2;\n+\t\t\t\t\tmRotateDegree = BASE_DEGREE - mScrollX * degreePerPix;\n+\t\t\t\t}\n+\t\t\t\tmDeep = 0;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase 4:\n+\t\t\tmDx = -Image3DSwitchView.IMAGE_PADDING * 2;\n+\t\t\tmRotateDegree = (2 * mWidth - mScrollX) * degreePerPix;\n+\t\t\tif (mScrollX > mWidth) {\n+\t\t\t\tmDeep = 0;\n+\t\t\t} else {\n+\t\t\t\tmDeep = (mWidth - mScrollX) * deepPerPix;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * 判断当前图片是否可见。\n+\t * \n+\t * @return 当前图片可见返回true，不可见返回false。\n+\t */\n+\tprivate boolean isImageVisible() {\n+\t\tboolean isVisible = false;\n+\t\tswitch (mIndex) {\n+\t\tcase 0:\n+\t\t\tif (mScrollX < (mLayoutWidth - mWidth) / 2 - mWidth) {\n+\t\t\t\tisVisible = true;\n+\t\t\t} else {\n+\t\t\t\tisVisible = false;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase 1:\n+\t\t\tif (mScrollX > (mLayoutWidth - mWidth) / 2) {\n+\t\t\t\tisVisible = false;\n+\t\t\t} else {\n+\t\t\t\tisVisible = true;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase 2:\n+\t\t\tif (mScrollX > mLayoutWidth / 2 + mWidth / 2\n+\t\t\t\t\t|| mScrollX < -mLayoutWidth / 2 - mWidth / 2) {\n+\t\t\t\tisVisible = false;\n+\t\t\t} else {\n+\t\t\t\tisVisible = true;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase 3:\n+\t\t\tif (mScrollX < -(mLayoutWidth - mWidth) / 2) {\n+\t\t\t\tisVisible = false;\n+\t\t\t} else {\n+\t\t\t\tisVisible = true;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase 4:\n+\t\t\tif (mScrollX > mWidth - (mLayoutWidth - mWidth) / 2) {\n+\t\t\t\tisVisible = true;\n+\t\t\t} else {\n+\t\t\t\tisVisible = false;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\treturn isVisible;\n+\t}\n+\n+}\n\\ No newline at end of file"
  }, {
    "sha" : "3ab808712fbeb72e72d25267c5047fbcb3f88f60",
    "filename" : "app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203MainActivity.java",
    "status" : "added",
    "additions" : 37,
    "deletions" : 0,
    "changes" : 37,
    "blob_url" : "https://github.com/hzuapps/android-labs/blob/f96ca14dc2ac6390a5bf84b9c2216dbbcc86a16e/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203MainActivity.java",
    "raw_url" : "https://github.com/hzuapps/android-labs/raw/f96ca14dc2ac6390a5bf84b9c2216dbbcc86a16e/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203MainActivity.java",
    "contents_url" : "https://api.github.com/repos/hzuapps/android-labs/contents/app/src/main/java/edu/hzuapps/androidworks/homeworks/net1314080903203/Net1314080903203MainActivity.java?ref=f96ca14dc2ac6390a5bf84b9c2216dbbcc86a16e",
    "patch" : "@@ -0,0 +1,37 @@\n+﻿package com.example.imageswitchviewtest;\n+\n+import android.app.Activity;\n+import android.os.Bundle;\n+\n+import com.example.imageswitchviewtest.Image3DSwitchView.OnImageSwitchListener;\n+\n+/**\n+ * 项目主Activity。\n+ * \n+\n+ */\n+public class Net1314080903203MainActivity extends Activity {\n+\n+\tprivate Image3DSwitchView imageSwitchView;\n+\n+\t@Override\n+\tprotected void onCreate(Bundle savedInstanceState) {\n+\t\tsuper.onCreate(savedInstanceState);\n+\t\tsetContentView(R.layout.activity_main);\n+\t\timageSwitchView = (Image3DSwitchView) findViewById(R.id.image_switch_view);\n+\t\timageSwitchView.setOnImageSwitchListener(new OnImageSwitchListener() {\n+\t\t\t@Override\n+\t\t\tpublic void onImageSwitch(int currentImage) {\n+\t\t\t\t// Log.d(\"TAG\", \"current image is \" + currentImage);\n+\t\t\t}\n+\t\t});\n+\t\timageSwitchView.setCurrentImage(1);\n+\t}\n+\n+\t@Override\n+\tprotected void onDestroy() {\n+\t\tsuper.onDestroy();\n+\t\timageSwitchView.clear();\n+\t}\n+\n+}"
  } ],
  "sha" : "f96ca14dc2ac6390a5bf84b9c2216dbbcc86a16e",
  "url" : "https://api.github.com/repos/hzuapps/android-labs/commits/f96ca14dc2ac6390a5bf84b9c2216dbbcc86a16e",
  "parents" : [ {
    "sha" : "8f6dfc5d253939a32cdbdb69a793582f6a1fc74d",
    "url" : "https://api.github.com/repos/hzuapps/android-labs/commits/8f6dfc5d253939a32cdbdb69a793582f6a1fc74d",
    "html_url" : "https://github.com/hzuapps/android-labs/commit/8f6dfc5d253939a32cdbdb69a793582f6a1fc74d"
  } ]
}